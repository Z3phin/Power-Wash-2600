
	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

        seg.u Variables
	org $80

temp			.byte	; Temp variable, used for variety of purposees

dirt_height_counter 	.byte

random_num_index	.byte	; Represents the line of code used to generate a random number

row_cleaned		.byte

frame_counter 		.byte

win_frame_counter	.byte

is_game_won		.byte

bk_colour 		.byte

;sound channels
sound_channel_0		.byte
sound_channel_1 	.byte
;area information
area_index		.byte
area_bk_colour		.byte
area_dirt_colour	.byte
;scores 
score_0			.byte	; Player 0 score
score_1			.byte   ; Player 1 score
scores 			 equ (score_0) ; Easy indexable name
;player x positions 
p0_x_position		.byte	
p1_x_position		.byte
x_positions	         equ (p0_x_position) ; Easy indexable name
;player colours
p0_colour   		.byte	; Player0 colour on given scanline
p1_colour		.byte	; Player1 colour on given scanline
; Missile Positions
m0_y_position		.byte    
m1_y_position		.byte
missile_y_positions	 equ (m0_y_position)
m0_x_position		.byte ; FUNCTIONALLY UNUSED 
m1_x_position		.byte ; FUNCTIONALLY UNUSED	
missile_x_positions	 equ (m0_x_position)
; Missile Velocities
m0_velocity		.byte
m1_velocity		.byte
missile_velocitiies 	 equ (m0_velocity)
; Missile Colours
m0_colour  		.byte
m1_colour  		.byte
missile_colours		 equ (m0_colour)


; Sprite Pointers
p0_colour_ptr		.word
p1_colour_ptr		.word
p0_sprite_ptr		.word
p1_sprite_ptr		.word

; Score Font Buffer 2x5 array
font_buffer 		ds 10

; Dirt (column major)
dirt_array		ds 72	; 6x12 bytes (PF0-PF1-PF2-PF0-PF1-PF2)

; Constants 
SPRITE_HEIGHT 		equ #21
PLAYER_0_COLOUR 	equ $94
PLAYER_1_COLOUR 	equ $42
PLAYER_0_WIN_COLOUR	equ $97
PLAYER_1_WIN_COLOUR	equ $40
PLAYER_0_SCORE_COLOUR	equ $98
PLAYER_1_SCORE_COLOUR	equ $46
FLOOR_COLOUR		equ $04

P0_START_POSITION	equ #40
P1_START_POSITION	equ #112
RETICLE_START		equ #70

MAX_WIN_FRAMES 		equ #150	

DIRT_HEIGHT		equ #4	; Height of each dirt spot in 2xScanlines
NUM_DIRT_ROWS		equ #12	; Number of dirt rows 
NDR			equ NUM_DIRT_ROWS
DIRT_Y_START		equ #32 

NUM_AREAS		equ #4

RETICLE_OFFSET		equ #4

RETICLE_SIZE 		equ #%00011000
WATER_SIZE		equ #0

WATER_COLOUR    	equ #$af

PLAYER_0_SPRITE 	equ #0
PLAYER_1_SPRITE 	equ #1
MISSILE_0_SPRITE 	equ #2
MISSILE_1_SPRITE	equ #3

PLAYER_OFF		equ #0
CLEAR_PLAYFIELD		equ #0
MISSILE_OFF		equ #0
MISSILE_ON		equ #2

AUDIO_CHANNEL_0		equ #0
AUDIO_CHANNEL_1		equ #1
MUTE_VOLUME 		equ #0

ROW_CLEANED_SOUND 	equ #3
POWER_WASHER_SOUND	equ #5
START_WIN_SOUND 	equ #6
MIDDLE_WIN_SOUND	equ #7
END_WIN_SOUND		equ #8

LAST_ANIMATION_FRAME    equ #3
LAST_START_SOUND_FRAME	equ #100
LAST_MIDDLE_SOUND_FRAME equ #70

SCOREBOARD_BACKGROUND_COLOUR equ #$00

MISSILE_PLAYFIELD_COLLISION equ #%11000000

PLAYFIELD_SCORE_MODE	equ #%00010010
PLAYFIELD_MODE_RESET	equ #%00000000

SCORE_DIGIT_HEIGHT 	equ #10
SCORE_BUFFER_HEIGHT	equ #7

HALF_ROW		equ #$F0
FULL_ROW		equ #$FF

COLOR_SWITCH		equ #%00001000

RIGHT_MOST_BITS		equ #%00000011
RIGHT_MIDDLE_BITS	equ #%00001100
LEFT_MOST_BITS		equ #%11000000
LEFT_MIDDLE_BITS	equ #%00110000


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment

	seg Code
        org $f000
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	              START
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Start
	CLEAN_START
        
        ; Temporary setup of dirt
        ldx #0
	jsr LoadDirt
        ldx #1
        jsr LoadDirt
        		
        ; Setting Player Sprite Pointers 
        
        jsr SetUpPtrs
        
        lda #MAX_WIN_FRAMES
        sta win_frame_counter
        
        lda #0
        sta area_index
        
        tax
        
        lda DirtColours,x
        sta area_dirt_colour
        
        lda BackgroundColours,x
        sta area_bk_colour
        sta bk_colour
        
        ; Intitial Scores and missile positions
        lda #0
        sta score_0
        sta score_1
        
        
        lda #%10000000
        ; Set Missiles off? 
        sta m0_velocity
        sta m1_velocity
        

        ; Set Reticles to top
        lda #RETICLE_START
        sta m0_y_position
        sta m1_y_position
        
        ; Initial Player and missile X positions
        ; Player 0
       	lda #P0_START_POSITION
        sta p0_x_position
        sta m0_x_position
        
        ; Player 1
        lda #P1_START_POSITION
        sta p1_x_position
        sta m1_x_position
        
        ; Set delay for displaying P0 until GRP1 is set
        lda #1
        sta VDELP0	
         
        ; Set horizontal positions 
        lda p0_x_position
        ldx #PLAYER_0_SPRITE
        jsr SetHorizPos
        
        lda p1_x_position
        ldx #PLAYER_1_SPRITE
        jsr SetHorizPos
        
        sta WSYNC
        sta HMOVE

NextFrame
        lsr SWCHB	; test Game Reset switch
        bcc Start	; reset?
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	         VERTICAL SYNC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        
; 1 + 3 lines of VSYNC
	VERTICAL_SYNC
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	       END VERTICAL SYNC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	         VERTICAL BLANK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        
; 37 lines of underscan
	TIMER_SETUP 37 
        
        jsr ProcessSound
        
       	; Setup the scores ready for display
Setup_Scoreboard
        lda score_0
        ldx #0
        jsr GetBCDBitmap
        lda score_1
        ldx #5
        jsr GetBCDBitmap
        
        ; Setup background colour and scoremode ready for scoreboard
        lda #SCOREBOARD_BACKGROUND_COLOUR
        sta COLUBK
        
        lda #0
        sta CTRLPF	; Symmetry
        
; Set the horizontal position of players
Set_Player_Positions
        lda p0_x_position
        ldx #PLAYER_0_SPRITE
        jsr SetHorizPos

        lda p1_x_position
        ldx #PLAYER_1_SPRITE
        jsr SetHorizPos
        
; Offset the missile0 to the center of sprite0
Set_Missile_Positions
        lda p0_x_position
        clc
        adc #RETICLE_OFFSET	; Offset
        ldx #MISSILE_0_SPRITE
        jsr SetHorizPos
        
        ; Offset the missile1 to the center of sprite1
        lda p1_x_position
        clc
        adc #RETICLE_OFFSET
        ldx #MISSILE_1_SPRITE
        jsr SetHorizPos
        
; Make the missile big if it is Reticle Mode for player 0
Set_P0_Missile_Size
        lda m0_velocity
        bmi .enable_cursor_size_0
        lda #WATER_SIZE
        jmp .store_cursor_size_0
.enable_cursor_size_0
	lda #RETICLE_SIZE
.store_cursor_size_0
	sta NUSIZ0

; Make the missile big if it is Reticle Mode for player 1
Set_P1_Missile_Size
        lda m1_velocity
        bmi .enable_cursor_size_1
        lda #WATER_SIZE
        jmp .store_cursor_size_1
.enable_cursor_size_1
	lda #RETICLE_SIZE
.store_cursor_size_1
	sta NUSIZ1
        
; Recolour missile for either Reticle Mode or Stream Mode
Set_P0_Missile_Colour
        lda m0_velocity
        bmi .enable_reticle_colour_0
        lda #WATER_COLOUR
        jmp .store_missile_colour_0
.enable_reticle_colour_0
	lda #PLAYER_0_COLOUR
.store_missile_colour_0
	sta m0_colour
        
; Recolour missile for either Reticle Mode or Stream Mode
Set_P1_Missile_Colour
        lda m1_velocity
        bmi .enable_reticle_colour_1
        lda #WATER_COLOUR
        jmp .store_missile_colour_1
.enable_reticle_colour_1
	lda #PLAYER_1_COLOUR
.store_missile_colour_1
	sta m1_colour
        
        
        sta WSYNC
        sta HMOVE ; Apply horizontal offset 
       
        TIMER_WAIT
; 192 lines of frame

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	      END VERTICAL BLANK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	        MAIN DRAWING
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
	
        TIMER_SETUP 192
        
        
        jsr DrawScoreboard
        
Load_Area_Colours
        lda bk_colour
        sta COLUBK
        lda area_dirt_colour
        sta COLUPF
        
Turn_Off_Player_Sprites
        lda #0
        sta GRP0
        sta GRP1
        
Load_Missile_Colours
        lda m0_colour
        sta COLUP0
        lda m1_colour
        sta COLUP1
        
        sta WSYNC
                
;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; DIRT GRAPHICS LOOP
; Dirt is made up of blocks with a height (number of scanlines/2).
; The inner loop is repeated until all scanlines have been drawn.
; Once the complete height of a block is draw, the next row is begins to be drawn
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        
        ; Y contains the dirt row we are on.
        ; X contains the scanline we are on.
        
        ldy #$ff ; Start at -1 ; will immediately increment to 0  
        ldx #$ff ; Incremented every scanline
Draw_Dirt_Loop
        iny 			; Go to next brick row 
        lda #DIRT_HEIGHT
        sta dirt_height_counter
        cpy #NUM_DIRT_ROWS
        bcs Draw_Dirt_Done
        
        
.inner_loop
	
; Enable missiles
; -------------------
	
	inx			; increment scanline counter
        stx temp
        sta WSYNC
        
; Clear Playfield registers 
        lda #CLEAR_PLAYFIELD			
        sta PF0
        sta PF1                        
        sta PF2
        
Draw_Missile_0
	; Is button held down? 
        lda m0_velocity	
        bmi .draw_reticle_0	
        
        ; Button is held down, draw water up to missile position
        lda m0_y_position
        cmp temp		; disable missile if scanline more than missile Y				
        bcc .enable_missile_0
        beq .enable_missile_0
	jmp .disable_missile_0
.draw_reticle_0
	lda m0_y_position
        cmp temp		
        beq .enable_missile_0		
.disable_missile_0
        lda #MISSILE_OFF
        jmp .finish_0
.enable_missile_0
	lda #MISSILE_ON
.finish_0
	sta ENAM0
            
Draw_Missile_1
	; Is button held down? 
        lda m1_velocity
        bmi .draw_reticle_1
        
        ; Button is held down, draw water up to missile position
        lda m1_y_position
        cmp temp		; disable missile if scanline more than missile Y				
        bcc .enable_missile_1
        beq .enable_missile_1
	jmp .disable_missile_1
.draw_reticle_1
	lda m1_y_position
        cmp temp		
        beq .enable_missile_1		
.disable_missile_1
        lda #MISSILE_OFF
        jmp .finish_1
.enable_missile_1
	lda #MISSILE_ON
.finish_1
	sta ENAM1	
        
        ; DO NOT DRAW DIRT IN BUFFER ZONE
        cpx #DIRT_Y_START
        bmi .inner_loop		
                           	
        
; Next Scanline - 
; Draw playfield data - Originally by Steven Hugg
; -----------------------------------
        
        sta WSYNC
        dec dirt_height_counter	
        
        
        ; HBLANK
        lda dirt_array+NUM_DIRT_ROWS*0,y ; 0+12*0,y
        sta PF0
        lda dirt_array+NUM_DIRT_ROWS*1,y ; 0+12*1,y	 
        sta PF1
        lda dirt_array+NUM_DIRT_ROWS*2,y
        sta PF2			 ; 21 machine cycles - 1 off HBLANK
      	; END HBLANK
      	
        inx			 ; Increment scanline counter	
        			 ; timing
       
        lda dirt_array+NUM_DIRT_ROWS*3,y
        sta PF0
        lda dirt_array+NUM_DIRT_ROWS*4,y
        sta PF1
        lda dirt_array+NUM_DIRT_ROWS*5,y
        sta PF2			  
        			 	 
        
        lda dirt_height_counter
        bne .inner_loop
        beq Draw_Dirt_Loop		

Draw_Dirt_Done 
	sta WSYNC
        
        ; Turn off missiles and playfield data
  	lda #CLEAR_PLAYFIELD ; MISSILE_OFF
        sta PF0
        sta PF1
        sta PF2
        sta ENAM0
        sta ENAM1
        
 ; DRAW PLAYER LOOP
 ; ----------------
        
        lda #SPRITE_HEIGHT
        sta temp
Draw_Sprite_Loop
	ldy temp
        
        lda (p0_colour_ptr),y	; Colour for both lines
        sta p0_colour		; A -> ColP0
        lda (p0_sprite_ptr),y	; Bitmap for first line
        sta GRP0		; A -> [GRP0] (delayed due to VDELP0)
        
        lda (p1_colour_ptr),y
        tax
        lda (p1_sprite_ptr),y
        tay
        
        lda p0_colour 
        sta WSYNC
        ; HBLANK
        sty GRP1	;GRP0 also updated due to VDELP0
        
        ; Store the player colours
        stx COLUP1
        sta COLUP0
        
        dec temp
        
        lda temp 
        sta WSYNC
        
        bne Draw_Sprite_Loop
        
        lda #FLOOR_COLOUR
        sta COLUBK
        
        ; TURN OFF PLAYER SPRITES 
        
        lda #PLAYER_OFF
        sta GRP0
        sta GRP1
     
               
        TIMER_WAIT

; 29 lines of overscan

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	       END MAIN DRAWING
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	            OVERSCAN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	TIMER_SETUP 29
        
        LDA is_game_won
        BNE Game_Won_Overscan	; 
        JMP Normal_Overscan	; Both will JMP to End_Frame 
End_Frame
	INC frame_counter
        TIMER_WAIT
	JMP NextFrame 		; -> back to beginning
       
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	          END OVERSCAN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Game_Won_Overscan
	lda #MUTE_VOLUME
        sta AUDV1
	
        ; Has the win animation completed? 
	lda win_frame_counter
        bne .animation_not_complete
        
        ; Win animation IS complete, begin next round
        jsr NewRound
        jmp End_Frame

	; Win animation NOT completed
        ; A - contains win_frame_counter (decreases)
.animation_not_complete
        ; Is animation on the last few frames? 
        cmp #LAST_ANIMATION_FRAME
        bcs .continue_animation
        
        ; Animation nearing end, begin loading dirt again (frames 1 and 2)
        ; 	split due to procedural calculation time
.load_dirt
        tax
        dex
        jsr LoadDirt
        dec win_frame_counter
        jmp End_Frame
                 
.continue_animation
        cmp #LAST_START_SOUND_FRAME
        bcc .play_middle_win_sound
        
.play_start_win_sound
        ldy #START_WIN_SOUND
        ldx #AUDIO_CHANNEL_1
        jsr PlaySound
        jsr WinAnimation
        jmp End_Frame      

.play_middle_win_sound
	cmp #LAST_MIDDLE_SOUND_FRAME
        bcc .play_end_win_sound
        ldy #MIDDLE_WIN_SOUND
        ldx #AUDIO_CHANNEL_1
        jsr PlaySound
        jsr WinAnimation
        jmp End_Frame 

.play_end_win_sound
        ldy #END_WIN_SOUND
        ldx #AUDIO_CHANNEL_1
        jsr PlaySound
	jsr WinAnimation
        jmp End_Frame



Normal_Overscan 
	lda m0_velocity
        bmi .p0_not_firing
        
        ldy #POWER_WASHER_SOUND
        ldx #AUDIO_CHANNEL_1
        jsr PlaySound 
        
 	ldx #PLAYER_0_SPRITE
 	jsr MissileCollision
        
.p0_not_firing
        lda m1_velocity
        bmi .p1_not_firing
        
        ldy #POWER_WASHER_SOUND
        ldx #AUDIO_CHANNEL_1
        jsr PlaySound 
        
        ldx #PLAYER_1_SPRITE
        jsr MissileCollision
.p1_not_firing 

	; Clear Collisions
        sta CXCLR
        
        jsr TestAllClean
        bmi .not_all_clean
        
        ; Indicate game is won and lock out input
        inc is_game_won
        jmp End_Frame
        
.not_all_clean
        ; Read Button Input for next frame
.read_input        
        lda INPT4
	sta m0_velocity
        
        lda INPT5
	sta m1_velocity 
       
        ; Read Movement Input
        jsr MoveJoystick0
        jsr MoveJoystick1
        jsr AnimatePlayer0
        jsr AnimatePlayer1
        
        jmp End_Frame
        ;------------

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 	  Subroutines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

WinAnimation subroutine

	lda win_frame_counter
        lsr	; SLOW DOWN ANIMATION
        lsr	;
        lsr	;
        lsr	;
        lsr	;
        lsr	; SLOW DOWN ANIMATION
        
        ; Should background change colour? 
        bcs .change_background_colour
        
        ; No, store current background colour
        lda area_bk_colour
        sta bk_colour
        dec win_frame_counter
	rts
        
.change_background_colour        
        lda score_0
        cmp score_1
        beq .draw
        bcc .player_1_win
        
.player_0_win
        lda #PLAYER_0_WIN_COLOUR
        sta bk_colour
        dec win_frame_counter
	rts
        
.player_1_win
        lda #PLAYER_1_WIN_COLOUR
        sta bk_colour
.draw
        dec win_frame_counter
	rts
        
NewRound subroutine
	inc area_index
        
        ; Should area index reset to zero after reaching max?
        lda area_index
        cmp #NUM_AREAS
        bne .load_area_colours
        lda #0
        sta area_index
.load_area_colours
        tax
        lda DirtColours,x
        sta area_dirt_colour
        lda BackgroundColours,x
        sta area_bk_colour
        
        jsr GameReset	
        rts



; x - contains the player missile and player score to add to
MissileCollision subroutine
	lda CXM0FB,x
        sta temp
	lda #MISSILE_PLAYFIELD_COLLISION
        bit temp
        bne .collision
        rts
        
.collision
	txa
        tay		; Move the player we are looking at into the Y register
        pha		; Save the contents of the X register
        
        lda missile_y_positions,y	; A contains missile Y coordinate  
        ldx x_positions,y	; X contains missile X coordinate
        
        jsr CleanDirt
        bpl .dirt_cleaned
        pla 
        tax
        rts

.dirt_cleaned
        pla
	tax		; Load the player we are looking at into the X register		

	; Add score if the whole row was cleaned
	lda row_cleaned
        beq .add_score
        rts

.add_score
        txa 
        pha
        
        ldy #ROW_CLEANED_SOUND
        ldx #AUDIO_CHANNEL_0
        jsr PlaySound
        
        pla
        tax
        
	; Add to the player score if a PF was cleaned
	clc
        sed 
        lda scores,x; MUST use ADC due to Binary Coded Decimal, cannot use INC
        adc #1	
        sta scores,x
        cld
	rts
        ; end add one to score
        

; Scoreboard Subroutines
; ----------------------
; Credit to 8Bitworkshop (Steven Hugg)

DrawScoreboard subroutine
	; Put playfield into score mode
        
        lda #PLAYFIELD_SCORE_MODE
        sta CTRLPF
        lda #PLAYER_0_SCORE_COLOUR   ; Slightly lighter colour than player0 sprite
        sta COLUP0 ; left colour
        lda #PLAYER_1_SCORE_COLOUR   ; Slightly lighter colour than player1 sprite		
        sta COLUP1 ; right colour	
        ; Draw digits
        ldy #0
.draw_loop
        sta WSYNC ; 76
        tya
        lsr	   ; Divide Y by two for double-height lines 	
        tax	   ; A -> X
        lda font_buffer+0,x
        sta PF1		; set left score bitmap	
        SLEEP 28
        lda font_buffer+5,x
        sta PF1		; set right score bitmap
        iny
        cpy #SCORE_DIGIT_HEIGHT
        bcc .draw_loop
        
        ; Clear playfield
        lda #CLEAR_PLAYFIELD
        sta WSYNC
        sta PF1
        ; Turn playfield reflection off (and turn score mode off)
        lda #PLAYFIELD_MODE_RESET
        sta CTRLPF
        
        ldx #SCORE_BUFFER_HEIGHT
        jsr BufferWSYNC
        
        rts

        
; GetBCDBitmap
; Fetches the bitmap data for two digits of a
; BCD-encoded number, storing it in addresses
; FontBuf+x to FontBuf+4+x
GetBCDBitmap subroutine 
	; Fetch the bytes for the 1st digit
        pha		; save original BCD number
        and #$0F	; mask out the least significant number
        sta temp
        asl 
        asl
        adc temp 	; multiply by 5
        tay		; A -> Y
        lda #5
        sta temp	; count down from 5
.loop1
	lda DigitsBitmap,y
        and #$0F	; mask out left most digit
        sta font_buffer,x 
        iny
        inx
        dec temp
        bne .loop1
        
        ; Second Digit 
        
	pla 		; restore original BCD number
        lsr
        lsr
        lsr
        lsr		;shift right by 4
        sta temp
        asl 
        asl
        adc temp	; multiply by 5
        tay 		; A -> Y
        dex
        dex
        dex
        dex
        dex
        lda #5
        sta temp 	; count down from 5
.loop2
	lda DigitsBitmap,y
        and #$F0	; make out rightmost digit
        ora font_buffer,x	; combine left and right digts
        sta font_buffer,x	; store combined digits
        iny
        inx
        dec temp
        bne .loop2
        rts
               
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; 			Clean Dirt
;	     Originally created by Steven Hugg
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        


; Subroutine to try to clear a bit of dirt at a given X-Y coordinate.
; X contains the X coordinate.
; A contains the Y coordinate.
; On return, A = -1 if no dirt was present,
; otherwise A = Y offset (0-brickheight-1) of dirt hit.
CleanDirt
        ldy #$ff
        sec
        sbc #DIRT_Y_START	; subtract top Y of dirt field
; Divide by dirt height
DivideRowLoop
	iny
        sbc #DIRT_HEIGHT*2	; #
	bcs DivideRowLoop	; loop until < 0
        cpy #NUM_DIRT_ROWS		; #
        bcs NoBrickFound	
; Now that we have the line, get byte and bit offset for brick
	clc
        adc #DIRT_HEIGHT*2	; #
	pha	; save the remainder to return as result
	txa
        clc
        adc #3	; adjust because SetHorizPos is off by a few pixels
        lsr
        lsr	; divide X coordinate by 4
        tax	; transfer brick column to X
        tya	; load brick row # in A
        clc
        adc PFOfsTable,x	; add offset
        tay
        lda PFMaskTable,x
        eor #$ff
        and dirt_array,y
        cmp dirt_array,y		; was there a change?
        beq NoBrickFound2	; no, so return -1 as result
        sta dirt_array,y
        sta row_cleaned
        pla		; return remainder as result
        rts
NoBrickFound2
	pla		; pull the remainder, but ignore it
NoBrickFound
	lda #$FF	; return -1 as result
        rts

; Returns a negative number if not all clean 
TestAllClean subroutine	
	ldx #$FF
.check_row
	inx
	lda dirt_array+NUM_DIRT_ROWS*0,x
        and #HALF_ROW
        bne .not_clean
        
        lda dirt_array+NUM_DIRT_ROWS*1,x
        bne .not_clean
        
        lda dirt_array+NUM_DIRT_ROWS*2,x
        bne .not_clean
        
        lda dirt_array+NUM_DIRT_ROWS*3,x
        and #HALF_ROW
        bne .not_clean
        
        lda dirt_array+NUM_DIRT_ROWS*4,x
        bne .not_clean
        
        lda dirt_array+NUM_DIRT_ROWS*5,x
        bne .not_clean
        
        cpx #NUM_DIRT_ROWS-1
        bne .check_row
        rts
.not_clean
	lda #$FF ;-1
        rts
        
; X - contains which half to load procedurally (0 = left, 1 = right)                       
LoadDirt subroutine
	lda #COLOR_SWITCH
        bit SWCHB
        bne .procedural
        
        ; Is P2 difficulty expert? (is random mode selected)
        lda SWCHB
        bmi .random
        
        ; No, P2 is amateur
        jsr LoadFull
        rts
        ; Yes, P2 is expert
.random
	jsr LoadRandom
        rts
        
.procedural
	cpx #0
    	bne .second_procedural
	jsr LoadLeftProcedural
        rts
        
.second_procedural
	jsr LoadRightProcedural
        rts
        
LoadFull subroutine
	ldx #$FF	
.row_loop
	inx
        lda #HALF_ROW
        sta dirt_array+NUM_DIRT_ROWS*0,x
        sta dirt_array+NUM_DIRT_ROWS*3,x
        
        lda #FULL_ROW
        sta dirt_array+NUM_DIRT_ROWS*1,x
        sta dirt_array+NUM_DIRT_ROWS*2,x
        sta dirt_array+NUM_DIRT_ROWS*4,x
        sta dirt_array+NUM_DIRT_ROWS*5,x
        
        cpx #NUM_DIRT_ROWS-1
        bne .row_loop
        
        rts
        
LoadRandom subroutine
	ldx #$FF
        ldy random_num_index
.row_loop
	inx
	
        lda NextFrame,y
        and #HALF_ROW
        sta dirt_array+NUM_DIRT_ROWS*0,x
        
        iny
        lda NextFrame,y
        and #HALF_ROW
        sta dirt_array+NUM_DIRT_ROWS*3,x
        
        iny
        lda NextFrame,y
        sta dirt_array+NUM_DIRT_ROWS,x
        iny
        lda NextFrame,y
        sta dirt_array+NUM_DIRT_ROWS*2,x
        iny
        lda NextFrame,y
        sta dirt_array+NUM_DIRT_ROWS*4,x
        iny
        lda NextFrame,y
        sta dirt_array+NUM_DIRT_ROWS*5,x
        iny
        
        cpx #NUM_DIRT_ROWS-1
        bne .row_loop
        
        sty random_num_index
        rts
        
LoadLeftProcedural subroutine
	inc random_num_index
	ldx random_num_index
        lda Draw_Dirt_Loop,x
        sta temp
        
        ldy #$FF
.row_loop
        iny
        
        lda temp
        and #RIGHT_MOST_BITS 
        pha
        tax
        jsr GetProcData
	sta dirt_array+NUM_DIRT_ROWS,y
        pla
        tax
        jsr GetHalfProcData
	sta dirt_array+NUM_DIRT_ROWS*0,y
        
        lda temp
        and #RIGHT_MIDDLE_BITS
        lsr
        lsr
        tax
        jsr GetProcData
        sta dirt_array+NUM_DIRT_ROWS*2,y

      	cpy #NUM_DIRT_ROWS-1
        bne .row_loop
       
	rts
        
LoadRightProcedural subroutine
	ldx random_num_index
        lda Draw_Dirt_Loop,x
        sta temp
        
        ldy #$FF
.row_loop
        iny
        
	lda temp
        and #LEFT_MIDDLE_BITS
        lsr
        lsr
        lsr
        lsr
        tax
        jsr GetProcData
       	sta dirt_array+NUM_DIRT_ROWS*4,y
        
        lda temp
        and #LEFT_MOST_BITS
        rol
        rol
        rol
        pha
        tax
        jsr GetProcData
        sta dirt_array+NUM_DIRT_ROWS*5,y
        pla
        tax
        jsr GetHalfProcData
        sta dirt_array+NUM_DIRT_ROWS*3,y
        
      	cpy #NUM_DIRT_ROWS-1
        bne .row_loop
       
	rts


; X contains ProcData index (0,1,2,3)
; Y contains row index (0-11)
; A will contain output
GetProcData subroutine
        bne .next1
        lda ProcData+NUM_DIRT_ROWS*0,y
        jmp .load
.next1
        dex
        bne .next2
        lda ProcData+NUM_DIRT_ROWS*1,y
        jmp .load
.next2	
        dex
        bne .next3
	lda ProcData+NUM_DIRT_ROWS*2,y
        jmp .load
.next3
      	lda ProcData+NUM_DIRT_ROWS*3,y
.load   
        rts
        
; X contains ProcData index (0,1,2,3)
; Y contains row index (0-11)
; A will contain output
GetHalfProcData subroutine
        bne .next1
        lda HalfProcData+NUM_DIRT_ROWS*0,y
        jmp .load
.next1
        dex
        bne .next2
        lda HalfProcData+NUM_DIRT_ROWS*1,y
        jmp .load
.next2	
        dex
        bne .next3
	lda HalfProcData+NUM_DIRT_ROWS*2,y
        jmp .load
.next3
      	lda HalfProcData+NUM_DIRT_ROWS*3,y
.load    
        rts
	
	
    
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; 		Joystick Input Subroutines 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Player 0 Movement
; ----------------

; Read joystick movement and apply to object 0
MoveJoystick0 subroutine
; Move horizontally
        ldx p0_x_position
	lda #%01000000	;Left?	
	bit SWCHA
	bne .SkipMoveLeft
        cpx #1
        bcc .SkipMoveLeft
        dex
.SkipMoveLeft
	lda #%10000000	;Right?
	bit SWCHA 
	bne .SkipMoveRight
        cpx #153
        bcs .SkipMoveRight
        inx
.SkipMoveRight
	stx p0_x_position
; Move Vertically
	ldy m0_y_position
        lda #%00010000	;Up?
        bit SWCHA
        bne .SkipMoveUp
        cpy #1
        bcc .SkipMoveUp
        dey
        dey
.SkipMoveUp
        lda #%00100000	;down?
        bit SWCHA
        bne .SkipMoveDown
        cpy #DIRT_Y_START+DIRT_HEIGHT*2*NUM_DIRT_ROWS
        bcs .SkipMoveDown
        iny
        iny
.SkipMoveDown
        sty m0_y_position  
        
	rts    
    
        
; Player 1 Movement
; ----------------
        
MoveJoystick1 subroutine 
; Move horizontally
        ldx p1_x_position
	lda #$04	;Left?
	bit SWCHA
	bne .SkipMoveLeft
        cpx #1		; Max Left
        bcc .SkipMoveLeft
        dex
.SkipMoveLeft
	lda #$08	;Right?
	bit SWCHA 
	bne .SkipMoveRight
        cpx #153	; Max Right
        bcs .SkipMoveRight
        inx
.SkipMoveRight
	stx p1_x_position
        
; Move Vertically
	ldy m1_y_position
        lda #$01	;Up?
        bit SWCHA
        bne .SkipMoveUp
        cpy #1
        bcc .SkipMoveUp
        dey
        dey
.SkipMoveUp
        lda #$02	;down?
        bit SWCHA
        bne .SkipMoveDown
        cpy #DIRT_Y_START+DIRT_HEIGHT*2*NUM_DIRT_ROWS
        bcs .SkipMoveDown
        iny
        iny
.SkipMoveDown
        sty m1_y_position   
        
	rts

AnimatePlayer0 subroutine
        lda #$C0
	and SWCHA
        cmp #$C0
        beq .idle
        
	lda frame_counter
        lsr
        lsr
        lsr
        lsr
       	
        bcs .SetFrame2
        
        lda #<Frame1
        sta p0_sprite_ptr
        lda #>Frame1
        sta p0_sprite_ptr+1
        jmp .return
.SetFrame2
 	lda #<Frame2
        sta p0_sprite_ptr
        lda #>Frame2
        sta p0_sprite_ptr+1
	jmp .return
.idle
	lda #<Frame0
        sta p0_sprite_ptr
        lda #>Frame0
        sta p0_sprite_ptr+1
.return   
        rts
        
AnimatePlayer1 subroutine 
        lda #$0C
	and SWCHA
        cmp #$0C
        beq .idle
        
	lda frame_counter
        lsr
        lsr
        lsr
        lsr
       	
        bcs .SetFrame2
        
        lda #<Frame1
        sta p1_sprite_ptr
        lda #>Frame1
        sta p1_sprite_ptr+1
        jmp .return
.SetFrame2
 	lda #<Frame2
        sta p1_sprite_ptr
        lda #>Frame2
        sta p1_sprite_ptr+1
	jmp .return
.idle
	lda #<Frame0
        sta p1_sprite_ptr
        lda #>Frame0
        sta p1_sprite_ptr+1
.return   
        rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 		Set Horizontal Position
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The X register contains the index of the desired object:
;  X=0: player 0
;  X=1: player 1
;  X=2: missile 0
;  X=3: missile 1
;  X=4: ball
SetHorizPos subroutine
	sta WSYNC	; start a new line
        bit 0		; waste 3 cycles
	sec		; set carry flag
DivideLoop
	sbc #15		; subtract 15
	bcs DivideLoop	; branch until negative
	eor #7		; calculate fine offset
	asl
	asl
	asl
	asl
	sta RESP0,x	; fix coarse position
	sta HMP0,x	; set fine offset
	rts		; return to caller
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 		      Miscellaneous 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        

GameReset subroutine 
	lda #MAX_WIN_FRAMES
        sta win_frame_counter
        
        lda area_bk_colour
        sta bk_colour
        
        ; Intitial Scores
        lda #0
        sta score_0
        sta score_1
        sta is_game_won
        
        lda #%10000000
        ; Set Missiles off? 
        sta m0_velocity
        sta m1_velocity
        
        ; Set Reticles to centre
        lda #RETICLE_START
        sta m0_y_position
        sta m1_y_position
        
        ; Initial Player and missile X positions
        ; Player 0
       	lda #P0_START_POSITION
        sta p0_x_position
        sta m0_x_position
        
        ; Player 1
        lda #P1_START_POSITION
        sta p1_x_position
        sta m1_x_position

	rts
         
SetUpPtrs subroutine
	lda #<Frame0
        sta p0_sprite_ptr
        sta p1_sprite_ptr
        
        lda #>Frame0
        sta p0_sprite_ptr+1
        sta p1_sprite_ptr+1
        
        lda #<ColourPlayer0
        sta p0_colour_ptr
        lda #>ColourPlayer0
        sta p0_colour_ptr+1
          
        lda #<ColourPlayer1
        sta p1_colour_ptr
        lda #>ColourPlayer1
        sta p1_colour_ptr+1
        
        rts
   
; Credit to 8Blit - Atari 2600 Game Programming
; Y contains the sound to play
; X contains the audio channel to play on (0 or 1)
PlaySound subroutine 
	; Is audio muted (P1 to Expert mode)
	lda SWCHB
        asl  
      	bmi .not_mute
        lda #MUTE_VOLUME
        sta AUDV0
        sta AUDV1
        rts
        
.not_mute
	lda SoundType,y
        sta AUDC0,x
        lda SoundVolume,y
        sta AUDV0,x
        lda SoundPitch,y
        sta AUDF0,x
        lda SoundLength,y
        sta sound_channel_0,x 
        rts
        
ProcessSound subroutine
	; Is audio muted (P1 to Expert Mode)
	lda SWCHB
        asl  
        bmi .not_mute
        lda #MUTE_VOLUME
        sta AUDV0
        sta AUDV1
        rts
        
.not_mute
	ldx #1
.soundChnl
	lda sound_channel_0,x
        beq .soundDone
        dec sound_channel_0,x
        bne .soundContinue
        lda #0
        sta AUDV0,x
.soundDone
.soundContinue
	dex
        beq .soundChnl
.return
	rts
        
; X - contains the number of scanlines to wait        
BufferWSYNC subroutine
	txa
        beq .none
.loop
	sta WSYNC
        dex 
        bne .loop
.none
	rts
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;		 Area Background and Dirt Colours
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        
        org $FE00
        
BackgroundColours
	.byte #$ba ;0
        .byte #$1a ;1
        .byte #$61 ;2
        .byte #$ff ;3
        
DirtColours
	.byte #$54 ;0
        .byte #$a0 ;1
        .byte #$1e ;2
        .byte #$d0 ;3
  
; Credit to 8Blit - Atari 2600 Game Programming  
SoundType
	.byte #$0C
        .byte #$02
        .byte #$06
        .byte #$06
        .byte #$08
        .byte #3
        .byte #12
        .byte #12
        .byte #12
SoundVolume
	.byte #$02
        .byte #$06
        .byte #$04
        .byte #$04
        .byte #$02
        .byte #$01
        .byte #2
        .byte #2
        .byte #2
SoundPitch
	.byte #$0D
        .byte #$03
        .byte #$09
        .byte #$03
        .byte #19
        .byte #13
        .byte #26
        .byte #19
        .byte #15
SoundLength
	.byte #$01
        .byte #$08
        .byte #$03
        .byte #$03
        .byte #4
        .byte #4
        .byte #4
        .byte #4
        .byte #4
        
ProcData
House
        .byte #%00011000;--
        .byte #%00111100;--
        .byte #%00111100;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01100110;--
        .byte #%01100110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01100110;--
        .byte #%01100110;--
        .byte #%01100110;--
TwoStory
        .byte #%01111100;--
        .byte #%11111110;--
        .byte #%10010010;--
        .byte #%10010010;--
        .byte #%11111110;--
        .byte #%10010010;--
        .byte #%10010010;--
        .byte #%11111110;--
        .byte #%11111110;--
        .byte #%11111110;--
        .byte #%11101110;--
        .byte #%11101110;--
Car
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00111110;--
        .byte #%00010010;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01100110;--      
Office
        .byte #%01111111;--
        .byte #%01010101;--
        .byte #%01111111;--
        .byte #%01010101;--
        .byte #%01111111;--
        .byte #%01010101;--
        .byte #%01111111;--
        .byte #%01010101;--
        .byte #%01111111;--
        .byte #%01010101;--
        .byte #%01111111;--
        .byte #%01111101;--
        
        
;---Graphics Data from PlayerPal 2600---

HalfProcData
SmallHouse
        .byte #%10000000;--
        .byte #%10000000;--
        .byte #%11000000;--
        .byte #%11100000;--
        .byte #%11110000;--
        .byte #%10010000;--
        .byte #%10010000;--
        .byte #%11110000;--
        .byte #%11010000;--
        .byte #%11010000;--
        .byte #%11010000;--
        .byte #%11110000;--
        
Bin
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00100000;--
        .byte #%01110000;--
        .byte #%01110000;--
        .byte #%01110000;--
        
House2
        .byte #%00000000;--
        .byte #%00010000;--
        .byte #%00010000;--
        .byte #%00110000;--
        .byte #%01110000;--
        .byte #%01110000;--
        .byte #%01010000;--
        .byte #%01010000;--
        .byte #%01010000;--
        .byte #%01010000;--
        .byte #%11110000;--
        .byte #%11110000;--
Flag
        .byte #%00000000;--
        .byte #%00100000;--
        .byte #%01100000;--
        .byte #%11100000;--
        .byte #%11100000;--
        .byte #%00100000;--
        .byte #%00100000;--
        .byte #%00100000;--
        .byte #%00100000;--
        .byte #%00100000;--
        .byte #%00100000;--
        .byte #%11110000;--
;---End Graphics Data---

	

	org $FF00
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;			     BITMAPS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Scoreboard digits bitmap
; ------------------------

; Credit to 8BitWorkshop, Steven Hugg
; Bitmap pattern for digits
DigitsBitmap ;;{w:8,h:5,count:10,brev:1};;
        .byte $EE,$AA,$AA,$AA,$EE
        .byte $22,$22,$22,$22,$22
        .byte $EE,$22,$EE,$88,$EE
        .byte $EE,$22,$66,$22,$EE
        .byte $AA,$AA,$EE,$22,$22
        .byte $EE,$88,$EE,$22,$EE
        .byte $EE,$88,$EE,$AA,$EE
        .byte $EE,$22,$22,$22,$22
        .byte $EE,$AA,$EE,$AA,$EE
        .byte $EE,$AA,$EE,$22,$EE
;;end


;      Player Bitmap
; ------------------------
            
;---Graphics Data from PlayerPal 2600---

Frame0
        .byte #%11111110;$02
        .byte #%01101100;$00
        .byte #%00101000;$00
        .byte #%01101100;$00
        .byte #%01101100;$94
        .byte #%01101100;$94
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%00111000;$94
        .byte #%01111100;$00
        .byte #%00111100;$94
        .byte #%01111010;$94
        .byte #%01110110;$94
        .byte #%11101110;$94
        .byte #%11011110;$94
        .byte #%11111110;$94
        .byte #%01111100;$00
        .byte #%00111000;$0E
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%00111000;$94
Frame1
        .byte #%10011110;$02
        .byte #%00001100;$00
        .byte #%00001000;$00
        .byte #%01101100;$00
        .byte #%01101100;$94
        .byte #%01101100;$94
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%00111000;$94
        .byte #%01111100;$00
        .byte #%00111100;$94
        .byte #%01111010;$94
        .byte #%01110110;$94
        .byte #%11101110;$94
        .byte #%11011110;$94
        .byte #%11111110;$94
        .byte #%01111100;$00
        .byte #%00111000;$0E
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%00111000;$94
Frame2
        .byte #%11110010;$02
        .byte #%01100000;$00
        .byte #%00100000;$00
        .byte #%01101100;$00
        .byte #%01101100;$94
        .byte #%01101100;$94
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%00111000;$94
        .byte #%01111100;$00
        .byte #%00111100;$94
        .byte #%01111010;$94
        .byte #%01110110;$94
        .byte #%11101110;$94
        .byte #%11011110;$94
        .byte #%11111110;$94
        .byte #%01111100;$00
        .byte #%00111000;$0E
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%00111000;$94
;---End Graphics Data---


;---Color Data from PlayerPal 2600---

ColourPlayer0
        .byte #$02;
        .byte #$00;
        .byte #$00;
        .byte #$00;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #$00;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #$00;
        .byte #$0E;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        
ColourPlayer1
        .byte #$02;
        .byte #$00;
        .byte #$00;
        .byte #$00;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #$00;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #$00;
        .byte #$0E;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
;---End Color Data---


; Credit to Steven Hugg
; Playfield bitmasks for all 40 dirt columns
PFMaskTable
	REPEAT 2
	.byte #$10,#$20,#$40,#$80
	.byte #$80,#$40,#$20,#$10,#$08,#$04,#$02,#$01
	.byte #$01,#$02,#$04,#$08,#$10,#$20,#$40,#$80
        REPEND

; Dirt array byte offsets for all 40 dirt columns
PFOfsTable
	.byte NDR*0,NDR*0,NDR*0,NDR*0
	.byte NDR*1,NDR*1,NDR*1,NDR*1, NDR*1,NDR*1,NDR*1,NDR*1
	.byte NDR*2,NDR*2,NDR*2,NDR*2, NDR*2,NDR*2,NDR*2,NDR*2
	.byte NDR*3,NDR*3,NDR*3,NDR*3
	.byte NDR*4,NDR*4,NDR*4,NDR*4, NDR*4,NDR*4,NDR*4,NDR*4
	.byte NDR*5,NDR*5,NDR*5,NDR*5, NDR*5,NDR*5,NDR*5,NDR*5

;---End Color Data---


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue

	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector
