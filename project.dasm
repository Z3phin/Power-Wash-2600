
	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

        seg.u Variables
	org $80

temp			.byte	; Temp variable, used for variety of purposees

dirt_height_counter 	.byte

random_num_index	.byte	; Represents the line of code used to generate a random number

row_cleaned		.byte

frame_counter 		.byte

win_frame_counter	.byte

is_game_won		.byte

bk_colour 		.byte

;sound channels
sound_channel_0		.byte
sound_channel_1 	.byte
;area information
area_index		.byte
area_bk_colour		.byte
area_dirt_colour	.byte
;scores 
score_0			.byte	; Player 0 score
score_1			.byte   ; Player 1 score
scores 			 equ (score_0) ; Easy indexable name
;player x positions 
p0_x_position		.byte	
p1_x_position		.byte
x_positions	         equ (p0_x_position) ; Easy indexable name
;player colours
p0_colour   		.byte	; Player0 colour on given scanline
p1_colour		.byte	; Player1 colour on given scanline
; Missile Positions
m0_y_position		.byte    
m1_y_position		.byte
missile_y_positions	 equ (m0_y_position)
m0_x_position		.byte ; FUNCTIONALLY UNUSED 
m1_x_position		.byte ; FUNCTIONALLY UNUSED	
missile_x_positions	 equ (m0_x_position)
; Missile Velocities
m0_velocity		.byte
m1_velocity		.byte
missile_velocitiies 	 equ (m0_velocity)
; Missile Colours
m0_colour  		.byte
m1_colour  		.byte
missile_colours		 equ (m0_colour)


; Sprite Pointers
p0_colour_ptr		.word
p1_colour_ptr		.word
p0_sprite_ptr		.word
p1_sprite_ptr		.word

; Score Font Buffer 2x5 array
font_buffer 		ds 10

; Dirt (column major)
dirt_array		ds 72	; 6x12 bytes (Dirt map)

; Constants 
SPRITE_HEIGHT 	equ #21
PLAYER_0_COLOUR equ $94
PLAYER_1_COLOUR equ $42
FLOOR_COLOUR	equ $04

P0_START_POSITION	equ #40
P1_START_POSITION	equ #112
RETICLE_START	equ #70

MAX_WIN_FRAMES 	equ #150

DIRT_HEIGHT	equ #4	; Height of each dirt spot in 2xScanlines
NUM_DIRT_ROWS	equ #12	; Number of dirt rows 
NDR		equ NUM_DIRT_ROWS
DIRT_Y_START	equ #32 

NUM_AREAS	equ #4



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment

	seg Code
        org $f000
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	              START
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Start
	CLEAN_START
        
        ; Temporary setup of dirt
        ldx #0
	jsr LoadDirt
        ldx #1
        jsr LoadDirt
        		
        ; Setting Player Sprite Pointers 
        
        jsr SetUpPtrs
        
        lda #MAX_WIN_FRAMES
        sta win_frame_counter
        
        lda #0
        sta area_index
        
        tax
        
        lda DirtColours,x
        sta area_dirt_colour
        
        lda BackgroundColours,x
        sta area_bk_colour
        sta bk_colour
        
        ; Intitial Scores and missile positions
        lda #0
        sta score_0
        sta score_1
        
        
        lda #%10000000
        ; Set Missiles off? 
        sta m0_velocity
        sta m1_velocity
        

        ; Set Reticles to top
        lda #RETICLE_START
        sta m0_y_position
        sta m1_y_position
        
        ; Initial Player and missile X positions
        ; Player 0
       	lda #P0_START_POSITION
        sta p0_x_position
        sta m0_x_position
        
        ; Player 1
        lda #P1_START_POSITION
        sta p1_x_position
        sta m1_x_position
        
        ; Set delay for displaying P0 until GRP1 is set
        lda #1
        sta VDELP0	
         
        ; Set horizontal positions 
        lda p0_x_position
        ldx #0
        jsr SetHorizPos
        
        lda p1_x_position
        ldx #1
        jsr SetHorizPos
        
        ldx #1
        sta WSYNC
        sta HMOVE

NextFrame
        lsr SWCHB	; test Game Reset switch
        bcc Start	; reset?
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	         VERTICAL SYNC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        
; 1 + 3 lines of VSYNC
	VERTICAL_SYNC
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	         VERTICAL BLANK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        
; 37 lines of underscan
	TIMER_SETUP 37 
        
        jsr ProcessSound
        
       	; Setup the scores ready for display  
        lda score_0
        ldx #0
        jsr GetBCDBitmap
        lda score_1
        ldx #5
        jsr GetBCDBitmap
          
        ; Set the horizontal position of players
        lda p0_x_position
        ldx #0
        jsr SetHorizPos
        
        lda p1_x_position
        ldx #1
        jsr SetHorizPos
        
        ; Offset the missile0 to the center of sprite0
        lda p0_x_position
        clc
        adc #4	; Offset
        ldx #2
        jsr SetHorizPos
        
        ; Offset the missile1 to the center of sprite1
        lda p1_x_position
        clc
        adc #4	; Offset
        ldx #3
        jsr SetHorizPos
        
	; Setup background colour and scoremode ready for scoreboard
        lda #$00
        sta COLUBK
        
        lda #0
        sta CTRLPF	; Symmetry
        
        
        ; Make the missile big if it is Reticle Mode for player 0
        lda m0_velocity
        bmi CursorSize0
        lda #0
        jmp StoreSize0
CursorSize0
	lda #%000011000
StoreSize0
	sta NUSIZ0

	; Make the missile big if it is Reticle Mode for player 1
        lda m1_velocity
        bmi CursorSize1
        lda #0
        jmp StoreSize1
CursorSize1
	lda #%00011000
StoreSize1
	sta NUSIZ1
        
        ; Recolour missile for either Reticle Mode or Stream Mode
        lda m0_velocity
        bmi ReticleColour0
        lda #$af 
        jmp StoreColour0
ReticleColour0
	lda #PLAYER_0_COLOUR
StoreColour0
	sta m0_colour
        
        ; Recolour missile for either Reticle Mode or Stream Mode
        lda m1_velocity
        bmi ReticleColour1
        lda #$af 
        jmp StoreColour1
ReticleColour1
	lda #PLAYER_1_COLOUR
StoreColour1
	sta m1_colour
        
        
        sta WSYNC
        sta HMOVE ; Apply horizontal offset 
       
        TIMER_WAIT
; 192 lines of frame
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	            DRAWING
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
	
        TIMER_SETUP 192
        jsr DrawScoreboard
        ldy #7
.buffer 
        sta WSYNC
        dey
        bne .buffer
        
        lda bk_colour
        sta COLUBK
        lda area_dirt_colour
        sta COLUPF
                
        lda #0
        sta GRP0
        sta GRP1
        lda m0_colour
        sta COLUP0
        lda m1_colour
        sta COLUP1
        
        sta WSYNC
                
        ; PLAYFIELD GRAPHICS LOOP
        ; ------------------
        
        ; Y contains the dirt row we are on.
        ; X contains the scanline we are on.
        
        ldy #$ff ; Start at -1 ; 
        ldx #$ff
DrawLoop
        iny 			; Go to next brick row 
        lda #DIRT_HEIGHT
        sta dirt_height_counter
        cpy #NUM_DIRT_ROWS
        bcs DoneDirtDraw
        
        
.innerLoop
	
        ; Enable missiles
        ; -------------------
	
	inx			; increment scanline counter
        stx temp
        sta WSYNC
        
        lda #0			
        sta PF0
        sta PF1                        
        sta PF2
        
        lda m0_velocity
        bmi .DrawReticle0	
        
        lda m0_y_position
        cmp temp		; If the scanline is more than the Missile Y, disable the missile				
        bcc .EnableMissile0
	jmp .DisableMissile0
.DrawReticle0
	lda m0_y_position
        cmp temp		
        beq .EnableMissile0		
.DisableMissile0
        lda #0
        jmp .Finish0
.EnableMissile0
	lda #2
.Finish0
	sta ENAM0
            
                
        lda m1_velocity
        bmi .DrawReticle1
        
        lda m1_y_position
        cmp temp		; If the scanline is more than the Missile Y, disable the missile				
        bcc .EnableMissile1
	jmp .DisableMissile1
.DrawReticle1
	lda m1_y_position
        cmp temp		
        beq .EnableMissile1		
.DisableMissile1
        lda #0
        jmp .Finish1
.EnableMissile1
	lda #2
.Finish1
	sta ENAM1	
        			              
        cpx #DIRT_Y_START
        bmi .innerLoop		
                           	
        
        ; Next Scanline - draw playfield data - Originally by Steven Hugg
        ; -----------------------------------
        sta WSYNC
        dec dirt_height_counter	
        
        
        ; HBLANK
        lda dirt_array+NUM_DIRT_ROWS*0,y ; 0+12*0,y
        sta PF0
        lda dirt_array+NUM_DIRT_ROWS*1,y ; 0+12*1,y	 
        sta PF1
        lda dirt_array+NUM_DIRT_ROWS*2,y
        sta PF2			 ; 21 machine cycles - 1 off HBLANK
      	; END HBLANK
      	
        inx			 ; Increment scanline counter	
        			 ; timing
       
        lda dirt_array+NUM_DIRT_ROWS*3,y
        sta PF0
        lda dirt_array+NUM_DIRT_ROWS*4,y
        sta PF1
        lda dirt_array+NUM_DIRT_ROWS*5,y
        sta PF2			 ; 21 machine cycles 
        			 ; TOTAL for PFx is 42 machine cycles. 76 - 42 machine cycles = 34	 
        
        lda dirt_height_counter
        bne .innerLoop
        beq DrawLoop		 ; Total 55 machine cycles used here, 21 machine cycles free 

DoneDirtDraw 
	sta WSYNC
        
        ; Turn off missiles and playfield data
  	lda #0
        sta PF0
        sta PF1
        sta PF2
        sta ENAM0
        sta ENAM1
        
 ; DRAW PLAYER LOOP
 ; ----------------
        
        lda #SPRITE_HEIGHT
        sta temp
DrawSpriteLoop
	ldy temp
        
        lda (p0_colour_ptr),y	; Colour for both lines
        sta p0_colour		; A -> ColP0
        lda (p0_sprite_ptr),y	; Bitmap for first line
        sta GRP0		; A -> [GRP0] (delayed due to VDELP0)
        
        lda (p1_colour_ptr),y
        tax
        lda (p1_sprite_ptr),y
        tay
        
        lda p0_colour 
        sta WSYNC
        ; HBLANK
        sty GRP1	;GRP0 also updated due to VDELP0
        
        ; Store the player colours
        stx COLUP1
        sta COLUP0
        
        dec temp
        
        lda temp 
        sta WSYNC
        
        bne DrawSpriteLoop
        
        lda #FLOOR_COLOUR
        sta COLUBK
        
        ; TURN OFF PLAYER SPRITES 
        
        lda #0
        sta GRP0
        sta GRP1
     
               
        TIMER_WAIT

; 29 lines of overscan

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	            OVERSCAN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	TIMER_SETUP 29
        
        lda is_game_won
        bne .gamewon
        jsr NormalOverscan
        jmp .next
        
.gamewon
	lda #0
        sta AUDV1
	
	lda win_frame_counter
        bne .noReset
        jsr NewRound
        jmp .next
.noReset
        cmp #2
        bne .noLoad
        ldx #0
        jsr LoadDirt
        dec win_frame_counter
        jmp .next
.noLoad 
	cmp #1
        bne .noLoad1
        ldx #1
        jsr LoadDirt
        dec win_frame_counter
        jmp .next
.noLoad1
        cmp #100
        bcc .skipSound0
        ldy #6
        ldx #1
        jsr PlaySound
        jmp .endofsound
.skipSound0
	cmp #70
        bcc .skipSound1
        ldy #7
        ldx #1
        jsr PlaySound
        jmp .endofsound
.skipSound1
        ldy #8
        ldx #1
        jsr PlaySound
.endofsound
	jsr GameWin
.next  
        inc frame_counter
        
        TIMER_WAIT
; total = 262 lines, go to next frame
        jmp NextFrame

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 					Subroutines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NormalOverscan subroutine
	lda m0_velocity
        bmi .noStream0
        
        ldy #5
        ldx #1
        jsr PlaySound 
        lda #0
        
 	ldx #0
 	jsr MissileCollision
.noStream0
        ; Skip Collisions in Reticle Mode
        lda m1_velocity
        bmi .noStream1
        
        ldy #5
        ldx #1
        jsr PlaySound  
        lda #0
        
        ldx #1
        jsr MissileCollision
.noStream1 

	; Clear Collisions
        sta CXCLR
        
        jsr TestAllClean
        bmi .noWin
        inc is_game_won
        jmp .gamewon
        
.noWin
        
        ; Read Button Input for next frame
        lda INPT4
	sta m0_velocity
        
        lda INPT5
	sta m1_velocity 
       
        ; Read Movement Input
        jsr MoveJoystick0
        jsr MoveJoystick1
        jsr AnimatePlayer0
        jsr AnimatePlayer1
.gamewon
        rts
        
GameWin subroutine

	lda win_frame_counter
        lsr
        lsr
        lsr
        lsr
        lsr
        lsr
        bcs .PlayerBK
        lda area_bk_colour
        sta bk_colour
        jmp .EndChangeColour
.PlayerBK        
        lda score_0
        cmp score_1
        bcc .Player1Win
        bcs .Player0Win
  	jmp .EndChangeColour
.Player1Win
        lda #PLAYER_1_COLOUR-3
        sta bk_colour
        jmp .EndChangeColour
.Player0Win
        lda #PLAYER_0_COLOUR+3
        sta bk_colour
.EndChangeColour
        dec win_frame_counter
	rts
        
NewRound subroutine
	inc area_index
        lda area_index
        cmp #NUM_AREAS
        bne .noResetArea
        lda #0
        sta area_index
.noResetArea
	lda area_index
        tax
        lda DirtColours,x
        sta area_dirt_colour
        lda BackgroundColours,x
        sta area_bk_colour
        
        jsr GameReset	
        rts


; x - contains the player missile and player score to add to
MissileCollision subroutine
	lda CXM0FB,x
        sta temp
	lda #%11000000
        bit temp
        beq .nocollision
.collision

	txa
        tay		; Move the player we are looking at into the Y register
        pha		; Save the contents of the X register
        
        lda missile_y_positions,y	; A contains missile Y coordinate  
        ldx x_positions,y	; X contains missile X coordinate
        
        jsr CleanDirt
        bmi .nocollision2
        
        pla
	tax		; Load the player we are looking at into the X register		

	lda row_cleaned
        bne .NoAddScore
        
        txa 
        pha
        
        ldy #3
        ldx #0
        jsr PlaySound
        
        pla
        tax
        
	; Add to the player score if a PF was cleaned
	clc
        sed 
        lda scores,x; MUST use ADC due to Binary Coded Decimal, cannot use INC
        adc #1	
        sta scores,x
        cld
.NoAddScore
        jmp .nocollision
        
.nocollision2
	pla
        tax
.nocollision
	rts
        ; end add one to score
        

; Scoreboard Subroutines
; ----------------------
; Credit to 8Bitworkshop (Steven Hugg)

DrawScoreboard subroutine
	; Put playfield into score mode
        
        lda #%00010010
        sta CTRLPF
        lda #$98   ; Slightly lighter colour than player0 sprite
        sta COLUP0 ; left colour
        lda #$46   ; Slightly lighter colour than player1 sprite		
        sta COLUP1 ; right colour	
        ; Draw digits
        ldy #0
ScanLoop1a
        sta WSYNC ; 76
        tya
        lsr	   ; Divide Y by two for double-height lines 	
        tax	   ; A -> X
        lda font_buffer+0,x
        sta PF1		; set left score bitmap	
        SLEEP 28
        lda font_buffer+5,x
        sta PF1		; set right score bitmap
        iny
        cpy #10
        bcc ScanLoop1a
        
        ; Clear playfield
        lda #0
        sta WSYNC
        sta PF1
        ; Turn playfield reflection off (and turn score mode off)
        lda #%00000000
        sta CTRLPF
        rts

        
; GetBCDBitmap
; Fetches the bitmap data for two digits of a
; BCD-encoded number, storing it in addresses
; FontBuf+x to FontBuf+4+x
GetBCDBitmap subroutine 
	; Fetch the bytes for the 1st digit
        pha		; save original BCD number
        and #$0F	; mask out the least significant number
        sta temp
        asl 
        asl
        adc temp 	; multiply by 5
        tay		; A -> Y
        lda #5
        sta temp	; count down from 5
.loop1
	lda DigitsBitmap,y
        and #$0F	; mask out left most digit
        sta font_buffer,x 
        iny
        inx
        dec temp
        bne .loop1
        
        ; Second Digit 
        
	pla 		; restore original BCD number
        lsr
        lsr
        lsr
        lsr		;shift right by 4
        sta temp
        asl 
        asl
        adc temp	; multiply by 5
        tay 		; A -> Y
        dex
        dex
        dex
        dex
        dex
        lda #5
        sta temp 	; count down from 5
.loop2
	lda DigitsBitmap,y
        and #$F0	; make out rightmost digit
        ora font_buffer,x	; combine left and right digts
        sta font_buffer,x	; store combined digits
        iny
        inx
        dec temp
        bne .loop2
        rts
               
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; 			Clean Dirt
;	     Originally created by Steven Hugg
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        


; Subroutine to try to clear a bit of dirt at a given X-Y coordinate.
; X contains the X coordinate.
; A contains the Y coordinate.
; On return, A = -1 if no dirt was present,
; otherwise A = Y offset (0-brickheight-1) of dirt hit.
CleanDirt
        ldy #$ff
        sec
        sbc #DIRT_Y_START	; subtract top Y of dirt field
; Divide by dirt height
DivideRowLoop
	iny
        sbc #DIRT_HEIGHT*2	; #
	bcs DivideRowLoop	; loop until < 0
        cpy #NUM_DIRT_ROWS		; #
        bcs NoBrickFound	
; Now that we have the line, get byte and bit offset for brick
	clc
        adc #DIRT_HEIGHT*2	; #
	pha	; save the remainder to return as result
	txa
        clc
        adc #3	; adjust because SetHorizPos is off by a few pixels
        lsr
        lsr	; divide X coordinate by 4
        tax	; transfer brick column to X
        tya	; load brick row # in A
        clc
        adc PFOfsTable,x	; add offset
        tay
        lda PFMaskTable,x
        eor #$ff
        and dirt_array,y
        cmp dirt_array,y		; was there a change?
        beq NoBrickFound2	; no, so return -1 as result
        sta dirt_array,y
        sta row_cleaned
        pla		; return remainder as result
        rts
NoBrickFound2
	pla		; pull the remainder, but ignore it
NoBrickFound
	lda #$FF	; return -1 as result
        rts

; Returns a negative number if not all clean 
TestAllClean subroutine	
	ldx #$FF
.CheckRow
	inx
	lda dirt_array+NUM_DIRT_ROWS*0,x
        and #$F0
        bne .NotClean
        
        lda dirt_array+NUM_DIRT_ROWS*1,x
        bne .NotClean
        
        lda dirt_array+NUM_DIRT_ROWS*2,x
        bne .NotClean
        
        lda dirt_array+NUM_DIRT_ROWS*3,x
        and #$F0
        bne .NotClean
        
        lda dirt_array+NUM_DIRT_ROWS*4,x
        bne .NotClean
        
        lda dirt_array+NUM_DIRT_ROWS*5,x
        bne .NotClean
        
        cpx #NUM_DIRT_ROWS-1
        bne .CheckRow
        rts
.NotClean
	lda #$FF
        rts
        
        
                
LoadDirt subroutine
	lda #%00001000
        bit SWCHB
        
        bne .procedural
        lda SWCHB
        bmi .random
        jsr LoadFull
        jmp .return
.random
	jsr LoadRandom
        jmp .return
.procedural
	cpx #0
    	bne .secondProc
	jsr LoadProcedural
        jmp .return
.secondProc
	jsr LoadProcedural1
.return
        rts
        
LoadFull subroutine
	ldx #$FF	
.FullLoop
	inx
        lda #$F0
        sta dirt_array+NUM_DIRT_ROWS*0,x
        sta dirt_array+NUM_DIRT_ROWS*3,x
        
        lda #$FF
        sta dirt_array+NUM_DIRT_ROWS*1,x
        sta dirt_array+NUM_DIRT_ROWS*2,x
        sta dirt_array+NUM_DIRT_ROWS*4,x
        sta dirt_array+NUM_DIRT_ROWS*5,x
        
        cpx #NUM_DIRT_ROWS-1
        bne .FullLoop
        
        rts
        
LoadRandom subroutine
	ldx #$FF
        ldy random_num_index
.randomLoop
	inx
	
        lda NextFrame,y
        and #$F0
        sta dirt_array+NUM_DIRT_ROWS*0,x
        
        iny
        lda NextFrame,y
        and #$F0
        sta dirt_array+NUM_DIRT_ROWS*3,x
        
        iny
        lda NextFrame,y
        sta dirt_array+NUM_DIRT_ROWS,x
        iny
        lda NextFrame,y
        sta dirt_array+NUM_DIRT_ROWS*2,x
        iny
        lda NextFrame,y
        sta dirt_array+NUM_DIRT_ROWS*4,x
        iny
        lda NextFrame,y
        sta dirt_array+NUM_DIRT_ROWS*5,x
        iny
        
        cpx #NUM_DIRT_ROWS-1
        bne .randomLoop
        
        sty random_num_index
        rts
        
LoadProcedural subroutine
	inc random_num_index
	ldx random_num_index
        lda #%11000000 ;DrawLoop,x
        sta temp
        
        ldy #$FF
.ProceduralLoop
        iny
        
        lda temp
        and #$03 
        pha
        tax
        jsr GetProcData
	sta dirt_array+NUM_DIRT_ROWS,y
        pla
        tax
        jsr GetHalfProcData
	sta dirt_array+NUM_DIRT_ROWS*0,y
        
        lda temp
        and #$0C
        lsr
        lsr
        tax
        jsr GetProcData
        sta dirt_array+NUM_DIRT_ROWS*2,y

      	cpy #NUM_DIRT_ROWS-1
        bne .ProceduralLoop
       
	rts
        
LoadProcedural1 subroutine
	ldx random_num_index
        lda #%11000000 ;DrawLoop,x
        sta temp
        
        ldy #$FF
.ProceduralLoop
        iny
        
	lda temp
        and #$30
        lsr
        lsr
        lsr
        lsr
        tax
        jsr GetProcData
       	sta dirt_array+NUM_DIRT_ROWS*4,y
        
        lda temp
        and #$C0
        rol
        rol
        rol
        pha
        tax
        jsr GetProcData
        sta dirt_array+NUM_DIRT_ROWS*5,y
        pla
        tax
        jsr GetHalfProcData
        sta dirt_array+NUM_DIRT_ROWS*3,y
        
      	cpy #NUM_DIRT_ROWS-1
        bne .ProceduralLoop
       
	rts


; X contains ProcData index (0,1,2,3)
; Y contains row index (0-11)
; A will contain output
GetProcData subroutine
        bne .next1
        lda ProcData+NUM_DIRT_ROWS*0,y
        jmp .load
.next1
        dex
        bne .next2
        lda ProcData+NUM_DIRT_ROWS*1,y
        jmp .load
.next2	
        dex
        bne .next3
	lda ProcData+NUM_DIRT_ROWS*2,y
        jmp .load
.next3
      	lda ProcData+NUM_DIRT_ROWS*3,y
.load   
        rts
        
; X contains ProcData index (0,1,2,3)
; Y contains row index (0-11)
; A will contain output
GetHalfProcData subroutine
        bne .next1
        lda HalfProcData+NUM_DIRT_ROWS*0,y
        jmp .load
.next1
        dex
        bne .next2
        lda HalfProcData+NUM_DIRT_ROWS*1,y
        jmp .load
.next2	
        dex
        bne .next3
	lda HalfProcData+NUM_DIRT_ROWS*2,y
        jmp .load
.next3
      	lda HalfProcData+NUM_DIRT_ROWS*3,y
.load    
        rts
	
	
    
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; 		Joystick Input Subroutines 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Player 0 Movement
; ----------------

; Read joystick movement and apply to object 0
MoveJoystick0 subroutine
; Move horizontally
        ldx p0_x_position
	lda #%01000000	;Left?	
	bit SWCHA
	bne .SkipMoveLeft
        cpx #1
        bcc .SkipMoveLeft
        dex
.SkipMoveLeft
	lda #%10000000	;Right?
	bit SWCHA 
	bne .SkipMoveRight
        cpx #153
        bcs .SkipMoveRight
        inx
.SkipMoveRight
	stx p0_x_position
; Move Vertically
	ldy m0_y_position
        lda #%00010000	;Up?
        bit SWCHA
        bne .SkipMoveUp
        cpy #1
        bcc .SkipMoveUp
        dey
        dey
.SkipMoveUp
        lda #%00100000	;down?
        bit SWCHA
        bne .SkipMoveDown
        cpy #DIRT_Y_START+DIRT_HEIGHT*2*NUM_DIRT_ROWS
        bcs .SkipMoveDown
        iny
        iny
.SkipMoveDown
        sty m0_y_position  
        
	rts    
    
        
; Player 1 Movement
; ----------------
        
MoveJoystick1 subroutine 
; Move horizontally
        ldx p1_x_position
	lda #$04	;Left?
	bit SWCHA
	bne .SkipMoveLeft
        cpx #1		; Max Left
        bcc .SkipMoveLeft
        dex
.SkipMoveLeft
	lda #$08	;Right?
	bit SWCHA 
	bne .SkipMoveRight
        cpx #153	; Max Right
        bcs .SkipMoveRight
        inx
.SkipMoveRight
	stx p1_x_position
        
; Move Vertically
	ldy m1_y_position
        lda #$01	;Up?
        bit SWCHA
        bne .SkipMoveUp
        cpy #1
        bcc .SkipMoveUp
        dey
        dey
.SkipMoveUp
        lda #$02	;down?
        bit SWCHA
        bne .SkipMoveDown
        cpy #DIRT_Y_START+DIRT_HEIGHT*2*NUM_DIRT_ROWS
        bcs .SkipMoveDown
        iny
        iny
.SkipMoveDown
        sty m1_y_position   
        
	rts

AnimatePlayer0 subroutine
        lda #$C0
	and SWCHA
        cmp #$C0
        beq .idle
        
	lda frame_counter
        lsr
        lsr
        lsr
        lsr
       	
        bcs .SetFrame2
        
        lda #<Frame1
        sta p0_sprite_ptr
        lda #>Frame1
        sta p0_sprite_ptr+1
        jmp .return
.SetFrame2
 	lda #<Frame2
        sta p0_sprite_ptr
        lda #>Frame2
        sta p0_sprite_ptr+1
	jmp .return
.idle
	lda #<Frame0
        sta p0_sprite_ptr
        lda #>Frame0
        sta p0_sprite_ptr+1
.return   
        rts
        
AnimatePlayer1 subroutine 
        lda #$0C
	and SWCHA
        cmp #$0C
        beq .idle
        
	lda frame_counter
        lsr
        lsr
        lsr
        lsr
       	
        bcs .SetFrame2
        
        lda #<Frame1
        sta p1_sprite_ptr
        lda #>Frame1
        sta p1_sprite_ptr+1
        jmp .return
.SetFrame2
 	lda #<Frame2
        sta p1_sprite_ptr
        lda #>Frame2
        sta p1_sprite_ptr+1
	jmp .return
.idle
	lda #<Frame0
        sta p1_sprite_ptr
        lda #>Frame0
        sta p1_sprite_ptr+1
.return   
        rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 		Set Horizontal Position
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The X register contains the index of the desired object:
;  X=0: player 0
;  X=1: player 1
;  X=2: missile 0
;  X=3: missile 1
;  X=4: ball
SetHorizPos
	sta WSYNC	; start a new line
        bit 0		; waste 3 cycles
	sec		; set carry flag
DivideLoop
	sbc #15		; subtract 15
	bcs DivideLoop	; branch until negative
	eor #7		; calculate fine offset
	asl
	asl
	asl
	asl
	sta RESP0,x	; fix coarse position
	sta HMP0,x	; set fine offset
	rts		; return to caller
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 		      Miscellaneous 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        

GameReset subroutine 
	lda #MAX_WIN_FRAMES
        sta win_frame_counter
        
        lda area_bk_colour
        sta bk_colour
        
        ; Intitial Scores
        lda #0
        sta score_0
        sta score_1
        sta is_game_won
        
        lda #%10000000
        ; Set Missiles off? 
        sta m0_velocity
        sta m1_velocity
        
        ; Set Reticles to centre
        lda #RETICLE_START
        sta m0_y_position
        sta m1_y_position
        
        ; Initial Player and missile X positions
        ; Player 0
       	lda #P0_START_POSITION
        sta p0_x_position
        sta m0_x_position
        
        ; Player 1
        lda #P1_START_POSITION
        sta p1_x_position
        sta m1_x_position

	rts
        

        
        
SetUpPtrs subroutine
	lda #<Frame0
        sta p0_sprite_ptr
        sta p1_sprite_ptr
        
        lda #>Frame0
        sta p0_sprite_ptr+1
        sta p1_sprite_ptr+1
        
        lda #<ColourPlayer0
        sta p0_colour_ptr
        lda #>ColourPlayer0
        sta p0_colour_ptr+1
          
        lda #<ColourPlayer1
        sta p1_colour_ptr
        lda #>ColourPlayer1
        sta p1_colour_ptr+1
        
        rts
   
; Credit to 8Blit - Atari 2600 Game Programming
PlaySound subroutine 
	lda SWCHB
        asl  
        bmi .nomute
        lda #0
        sta AUDV0
        sta AUDV1
        jmp .return
.nomute
	lda SoundType,y
        sta AUDC0,x
        lda SoundVolume,y
        sta AUDV0,x
        lda SoundPitch,y
        sta AUDF0,x
        lda SoundLength,y
        sta sound_channel_0,x 
.return
        rts
        
ProcessSound subroutine
	lda SWCHB
        asl  
        bmi .nomute
        lda #0
        sta AUDV0
        sta AUDV1
        jmp .return
.nomute
	
	ldx #1
.soundChnl
	lda sound_channel_0,x
        beq .soundDone
        dec sound_channel_0,x
        bne .soundContinue
        lda #0
        sta AUDV0,x
.soundDone
.soundContinue
	dex
        beq .soundChnl
.return
	rts
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;		 Area Background and Dirt Colours
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        
        org $FE00
        
BackgroundColours
	.byte #$ba ;0
        .byte #$1a ;1
        .byte #$61 ;2
        .byte #$ff ;3
        
DirtColours
	.byte #$54 ;0
        .byte #$a0 ;1
        .byte #$1e ;2
        .byte #$d0 ;3
  
; Credit to 8Blit - Atari 2600 Game Programming  
SoundType
	.byte #$0C
        .byte #$02
        .byte #$06
        .byte #$06
        .byte #$08
        .byte #3
        .byte #12
        .byte #12
        .byte #12
SoundVolume
	.byte #$02
        .byte #$06
        .byte #$04
        .byte #$04
        .byte #$02
        .byte #$01
        .byte #2
        .byte #2
        .byte #2
SoundPitch
	.byte #$0D
        .byte #$03
        .byte #$09
        .byte #$03
        .byte #19
        .byte #13
        .byte #26
        .byte #19
        .byte #15
SoundLength
	.byte #$01
        .byte #$08
        .byte #$03
        .byte #$03
        .byte #4
        .byte #4
        .byte #4
        .byte #4
        .byte #4
        
ProcData
House
        .byte #%00011000;--
        .byte #%00111100;--
        .byte #%00111100;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01100110;--
        .byte #%01100110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01100110;--
        .byte #%01100110;--
        .byte #%01100110;--
TwoStory
        .byte #%01111100;--
        .byte #%11111110;--
        .byte #%10010010;--
        .byte #%10010010;--
        .byte #%11111110;--
        .byte #%10010010;--
        .byte #%10010010;--
        .byte #%11111110;--
        .byte #%11111110;--
        .byte #%11111110;--
        .byte #%11101110;--
        .byte #%11101110;--
Car
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00111110;--
        .byte #%00010010;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01100110;--      
Office
        .byte #%01111111;--
        .byte #%01010101;--
        .byte #%01111111;--
        .byte #%01010101;--
        .byte #%01111111;--
        .byte #%01010101;--
        .byte #%01111111;--
        .byte #%01010101;--
        .byte #%01111111;--
        .byte #%01010101;--
        .byte #%01111111;--
        .byte #%01111101;--
        
        
;---Graphics Data from PlayerPal 2600---

HalfProcData
SmallHouse
        .byte #%10000000;--
        .byte #%10000000;--
        .byte #%11000000;--
        .byte #%11100000;--
        .byte #%11110000;--
        .byte #%10010000;--
        .byte #%10010000;--
        .byte #%11110000;--
        .byte #%11010000;--
        .byte #%11010000;--
        .byte #%11010000;--
        .byte #%11110000;--
        
Bin
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00000000;--
        .byte #%00100000;--
        .byte #%01110000;--
        .byte #%01110000;--
        .byte #%01110000;--
        
House2
        .byte #%00000000;--
        .byte #%00010000;--
        .byte #%00010000;--
        .byte #%00110000;--
        .byte #%01110000;--
        .byte #%01110000;--
        .byte #%01010000;--
        .byte #%01010000;--
        .byte #%01010000;--
        .byte #%01010000;--
        .byte #%11110000;--
        .byte #%11110000;--
Flag
        .byte #%00000000;--
        .byte #%00100000;--
        .byte #%01100000;--
        .byte #%11100000;--
        .byte #%11100000;--
        .byte #%00100000;--
        .byte #%00100000;--
        .byte #%00100000;--
        .byte #%00100000;--
        .byte #%00100000;--
        .byte #%00100000;--
        .byte #%11110000;--
;---End Graphics Data---

	

	org $FF00
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;			     BITMAPS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Scoreboard digits bitmap
; ------------------------

; Credit to 8BitWorkshop, Steven Hugg
; Bitmap pattern for digits
DigitsBitmap ;;{w:8,h:5,count:10,brev:1};;
        .byte $EE,$AA,$AA,$AA,$EE
        .byte $22,$22,$22,$22,$22
        .byte $EE,$22,$EE,$88,$EE
        .byte $EE,$22,$66,$22,$EE
        .byte $AA,$AA,$EE,$22,$22
        .byte $EE,$88,$EE,$22,$EE
        .byte $EE,$88,$EE,$AA,$EE
        .byte $EE,$22,$22,$22,$22
        .byte $EE,$AA,$EE,$AA,$EE
        .byte $EE,$AA,$EE,$22,$EE
;;end


;      Player Bitmap
; ------------------------
            
;---Graphics Data from PlayerPal 2600---

Frame0
        .byte #%11111110;$02
        .byte #%01101100;$00
        .byte #%00101000;$00
        .byte #%01101100;$00
        .byte #%01101100;$94
        .byte #%01101100;$94
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%00111000;$94
        .byte #%01111100;$00
        .byte #%00111100;$94
        .byte #%01111010;$94
        .byte #%01110110;$94
        .byte #%11101110;$94
        .byte #%11011110;$94
        .byte #%11111110;$94
        .byte #%01111100;$00
        .byte #%00111000;$0E
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%00111000;$94
Frame1
        .byte #%10011110;$02
        .byte #%00001100;$00
        .byte #%00001000;$00
        .byte #%01101100;$00
        .byte #%01101100;$94
        .byte #%01101100;$94
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%00111000;$94
        .byte #%01111100;$00
        .byte #%00111100;$94
        .byte #%01111010;$94
        .byte #%01110110;$94
        .byte #%11101110;$94
        .byte #%11011110;$94
        .byte #%11111110;$94
        .byte #%01111100;$00
        .byte #%00111000;$0E
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%00111000;$94
Frame2
        .byte #%11110010;$02
        .byte #%01100000;$00
        .byte #%00100000;$00
        .byte #%01101100;$00
        .byte #%01101100;$94
        .byte #%01101100;$94
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%00111000;$94
        .byte #%01111100;$00
        .byte #%00111100;$94
        .byte #%01111010;$94
        .byte #%01110110;$94
        .byte #%11101110;$94
        .byte #%11011110;$94
        .byte #%11111110;$94
        .byte #%01111100;$00
        .byte #%00111000;$0E
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%01111100;$94
        .byte #%00111000;$94
;---End Graphics Data---


;---Color Data from PlayerPal 2600---

ColourPlayer0
        .byte #$02;
        .byte #$00;
        .byte #$00;
        .byte #$00;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #$00;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #$00;
        .byte #$0E;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        .byte #PLAYER_0_COLOUR;
        
ColourPlayer1
        .byte #$02;
        .byte #$00;
        .byte #$00;
        .byte #$00;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #$00;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #$00;
        .byte #$0E;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
        .byte #PLAYER_1_COLOUR;
;---End Color Data---


; Credit to Steven Hugg
; Playfield bitmasks for all 40 dirt columns
PFMaskTable
	REPEAT 2
	.byte #$10,#$20,#$40,#$80
	.byte #$80,#$40,#$20,#$10,#$08,#$04,#$02,#$01
	.byte #$01,#$02,#$04,#$08,#$10,#$20,#$40,#$80
        REPEND

; Dirt array byte offsets for all 40 dirt columns
PFOfsTable
	.byte NDR*0,NDR*0,NDR*0,NDR*0
	.byte NDR*1,NDR*1,NDR*1,NDR*1, NDR*1,NDR*1,NDR*1,NDR*1
	.byte NDR*2,NDR*2,NDR*2,NDR*2, NDR*2,NDR*2,NDR*2,NDR*2
	.byte NDR*3,NDR*3,NDR*3,NDR*3
	.byte NDR*4,NDR*4,NDR*4,NDR*4, NDR*4,NDR*4,NDR*4,NDR*4
	.byte NDR*5,NDR*5,NDR*5,NDR*5, NDR*5,NDR*5,NDR*5,NDR*5

;---End Color Data---


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue

	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector
