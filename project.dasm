
	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

        seg.u Variables
	org $80

Temp		byte	; Temp variable, used for variety of purposees
EnableMissiles  byte	; Used to store whether each missile is enabled on a scanline
			; ------XX, where bit 2 is player 1, bit 1 is player 0
ScanlineCounter	byte	; Counts which scanline we are on
tmpPF0		byte	; Temporary variable for holding playfield (PF0 register) data
tmpPF1		byte    ; Temporary variable for holding playfield (PF1 register) data
tmpPF2		byte    ; Temporary variable for holding playfield (PF2 register) data

; Scores 
Score0		byte	; Player 0 score
Score1		byte    ; Player 1 score

; Sprite Positions 
YPos0		byte	; TODO remove (old player 0 Y coordinate, now on constant Y)
YPos1		byte	; TODO remove (old player 0 Y coordinate, now on constant Y)
XPos0		byte	
XPos1		byte
YP0		byte    ; IDK, something to do with displaying players
YP1		byte    ; IDK, something to do with displaying player
ColP0   	byte	; Player0 colour on given scanline
ColP1		byte	; Player1 colour on given scanline

; Missile Positions
MissileY0	byte    
MissileY1	byte
MissileX0	byte
MissileX1	byte
MissileHeight0  byte
MissileVel0	byte
MissileVel1	byte

; Sprite Pointers

ColourPtr0	word
ColourPtr1	word
SpritePtr0	word
SpritePtr1	word


; Playfield Pointer

PFPtr		word

; Joystick Button 
Pressed 	byte

; Score Font Buffer 2x5 array
FontBuf 	ds 10


; Constants 
SpriteHeight 	equ 16

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment

	seg Code
        org $f000
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	              START
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Start
	CLEAN_START
        		
        ; Setting Player Sprite Pointers 
        
        lda #<Frame0
        sta SpritePtr0
        lda #>Frame0
        sta SpritePtr0+1
        
        lda #<ColourFrame0
        sta ColourPtr0
        lda #>ColourFrame0
        sta ColourPtr0+1
        
        lda #<Frame0
        sta SpritePtr1
        lda #>Frame0
        sta SpritePtr1+1
        
        lda #<ColourFrame0
        sta ColourPtr1
        lda #>ColourFrame0
        sta ColourPtr1+1
        
        ; Intitial Scores
        lda #0
        sta Score0
        sta Score1
        sta MissileHeight0
        
        ; Initial Player and missile Y Positions
        lda #255	; at position 0 and then adding more the player sprites move upwards
        sta YPos0
        sta MissileY0
        sta YPos1
        sta MissileY1
        
        lda #0
        sta MissileVel0
        sta MissileVel1
        
        ; Initial Plaayer and missile X positions
       	lda #40
        sta XPos0
        sta MissileX0
        lda #112
        sta XPos1
        sta MissileX1
        lda #1
        sta VDELP0	; Set delay for displaying P0 until GRP1 is set
         
        ; Set temporary counter and set horizontal position
        lda YPos0
        sta YP0
        lda YPos1
        sta YP1
        
        lda XPos0
        ldx #0
        jsr SetHorizPos
        
        lda XPos1
        ldx #1
        jsr SetHorizPos
        
        ldx #1
        sta WSYNC
        sta HMOVE

NextFrame
        lsr SWCHB	; test Game Reset switch
        bcc Start	; reset?
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	         VERTICAL SYNC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        
; 1 + 3 lines of VSYNC
	VERTICAL_SYNC
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	         VERTICAL BLANK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        
; 37 lines of underscan
	TIMER_SETUP 37 
        
        ; Setup background colour and scoremode ready for scoreboard
        lda #$00
        sta COLUBK
        lda #5
        sta CTRLPF	; Symmetry
        
       	; Setup the scores ready for display  
        lda Score0
        ldx #0
        jsr GetBCDBitmap
        lda Score1
        ldx #5
        jsr GetBCDBitmap
        
        ; Set temporary counter to position of players
        lda YPos0
        sta YP0
        lda YPos1
        sta YP1
        
        ; Set the horizontal position of players
        lda XPos0
        ldx #0
        jsr SetHorizPos
        
        lda XPos1
        ldx #1
        jsr SetHorizPos
        
        ; Offset the missile0 to the center of sprite0
        lda XPos0
        clc
        adc #4
        sta MissileX0
        ldx #2
        jsr SetHorizPos
        
        ; Offset the missile1 to the center of sprite1
        
        lda XPos1
        adc #4
        sta MissileX1
        ldx #3
        jsr SetHorizPos
        
        
        ; Move the missile upwards constantly by one scanline every frame until the given Y position of the missile
        ; Reset the missile to the player's position if it reaches the maximum height
        lda MissileY0
        sec
        sbc MissileVel0 ; decrease y position of missile by 2 per frame
        sbc MissileVel0
        cmp #115       ; Maximum height of the missile
        bcs .NoReset  
        ldy Pressed
        cpy #0
        bne .NoMoveY
        ; Reset the missile to the player with a velocity of 0
        lda #0
        sta MissileVel0 ; 0

        lda YPos0
.NoReset
        sta MissileY0  
.NoMoveY
        sta WSYNC
        sta HMOVE ; Apply horizontal offset 
       
        TIMER_WAIT
; 192 lines of frame
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	            DRAWING
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
	
        TIMER_SETUP 192 
        jsr DrawScoreboard
        
        ; Set Background to blue
        lda #$aa
        sta COLUBK
        
        ; DRAW PLAYER LOOP
        ; ----------------
        
        lda SpriteHeight
        sta Temp
DrawSpriteLoop
	ldy Temp
        
        lda (ColourPtr0),y	; Colour for both lines
        sta ColP0		; A -> ColP0
        lda (SpritePtr0),y	; Bitmap for first line
        sta GRP0		; A -> [GRP0] (delayed due to VDELP0)
        
        lda (ColourPtr1),y
        tax
        lda (SpritePtr1),y
        tay
        
        lda ColP0 
        sta WSYNC
        ; HBLANK
        sty GRP1	;GRP0 also updated due to VDELP0
        ; Store the player colours
        stx COLUP1
        sta COLUP0
        
        dec Temp
        
        lda Temp 
        sta WSYNC
        
        bne DrawSpriteLoop
        
        lda #0
        sta GRP0
        sta GRP1
        
        ; DRAW MISSILES LOOP (and later playfield graphics)
        ; ------------------
        
        ldy #0
DrawMissileLoop
	sty Temp
        lda MissileHeight0
        sec			; Set carry
        sbc Temp	        ; 0 - (-1)
        lda #2
        bcs .EnableMissile0
        lda #0
.EnableMissile0
        sta EnableMissiles
        
        lda MissileHeight0	; TODO Replace with 1
        sec			; Set carry
        sbc Temp	        ; 0 - (-1)
        bcc .EnableMissile1
        inc EnableMissiles
.EnableMissile1
        sta WSYNC

	; HBLANK
	lda EnableMissiles
        sta ENAM0
        asl
        sta ENAM1

	iny
        cpy #145
        bne DrawMissileLoop
  
         
        TIMER_WAIT

; 29 lines of overscan

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	            OVERSCAN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	TIMER_SETUP 29
       
        ; Max Player position = 175
        ; Minimum Player Position = 254
        ; YPos0 - MissileY0 = MissileHeight0
        ; 200 - 175 = 25
        ; 
        
        lda #0
        sec
        sbc MissileY0
        sta MissileHeight0
       
       
        jsr JoystickButton
        jsr FireButton0
        jsr FireButton1
        jsr MoveJoystick0
        jsr MoveJoystick1
        
        TIMER_WAIT
; total = 262 lines, go to next frame
        jmp NextFrame

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 					Subroutines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Scoreboard Subroutines
; ----------------------
DrawScoreboard subroutine
	; Put playfield into score mode
        
        lda #%00010010
        sta CTRLPF
        lda #$48
        sta COLUP0 ; left colour
        lda #$a8
        sta COLUP1 ; right colour
        ; Draw digits
        ldy #0
ScanLoop1a
        sta WSYNC ; 76
        tya
        lsr	   ; Divide Y by two for double-height lines 	
        tax	   ; A -> X
        lda FontBuf+0,x
        sta PF1		; set left score bitmap	
        SLEEP 28
        lda FontBuf+5,x
        sta PF1		; set right score bitmap
        iny
        cpy #10
        bcc ScanLoop1a
        
        ; Clear playfield
        lda #0
        sta WSYNC
        sta PF1
        ; Turn playfield reflection off (and turn score mode off)
        lda #%00010100
        sta CTRLPF
        rts

        
; GetBCDBitmap
; Fetches the bitmap data for two digits of a
; BCD-encoded number, storing it in addresses
; FontBuf+x to FontBuf+4+x
GetBCDBitmap subroutine 
	; Fetch the bytes for the 1st digit
        pha		; save original BCD number
        and #$0F	; mask out the least significant number
        sta Temp
        asl 
        asl
        adc Temp 	; multiply by 5
        tay		; A -> Y
        lda #5
        sta Temp	; count down from 5
.loop1
	lda DigitsBitmap,y
        and #$0F	; mask out left most digit
        sta FontBuf,x 
        iny
        inx
        dec Temp
        bne .loop1
        
        ; Second Digit 
        
	pla 		; restore original BCD number
        lsr
        lsr
        lsr
        lsr		;shift right by 4
        sta Temp
        asl 
        asl
        adc Temp	; multiply by 5
        tay 		; A -> Y
        dex
        dex
        dex
        dex
        dex
        lda #5
        sta Temp 	; count down from 5
.loop2
	lda DigitsBitmap,y
        and #$F0	; make out rightmost digit
        ora FontBuf,x	; combine left and right digts
        sta FontBuf,x	; store combined digits
        iny
        inx
        dec Temp
        bne .loop2
        rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;		   Drawing Subroutines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Draw Missiles
        
; Drawing Sprites

; This has to take a maximum of 152 machine cycles

DrawSprites subroutine
      	; Fetch Sprite 0 values 
         lda #SpriteHeight	; Height in 2xlines
         sec			; Set carry bit
         isb YP0			; Inc YP0, then SBC YP0 ; SpriteHeight-(YPO+1) at each scanline
        			; MissileHeight-(YP0+1)
        bcs .DoDraw0		; Inside bounds sprite bounds?
        lda #0			; If no, load the padding offset
.DoDraw0
	tay 			; A -> Y
        lda (ColourPtr0),y	; Colour for both lines
        sta ColP0		; A -> ColP0
        lda (SpritePtr0),y	; Bitmap for first line
        sta GRP0		; A -> [GRP0] (delayed due to VDELP0)
        
        ; Fetch sprite 1 values 
 
 	lda #SpriteHeight	; Height in 2xlines
        sec			; set carry bit
        isb YP1			; INC YP1, then SBC YP1
        bcs .DoDraw1		; inside bounds?
        lda #0			; If no, load the padding offset
.DoDraw1
	tay
        lda (ColourPtr1),y
        tax
        lda (SpritePtr1),y
        tay
        
        ; WSYNC and store sprite values
        lda ColP0 
        sta WSYNC
        ; HBLANK
        sty GRP1	; GRP0 also updated due to VDELP0
        ; Store the player colours
        stx COLUP1
        sta COLUP0
              
        rts

DrawMissiles
	lda MissileHeight0	; 0
        sec			; Set carry
        sbc YP0			; 0 - (-1)
        lda #2
        bcs .EnableMissile0
        lda #0
.EnableMissile0
        sta EnableMissiles
        
        ; TO GO IN HBLANK
        lda EnableMissiles
        sta ENAM0
        asl
        sta ENAM1
        
        rts
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; 		Joystick Input Subroutines 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Player 0 Movement
; ----------------

; Read joystick movement and apply to object 0
MoveJoystick0
; Move horizontally
        ldx XPos0
	lda #%01000000	;Left?
	bit SWCHA
	bne SkipMoveLeft
        cpx #1
        bcc SkipMoveLeft
        dex
SkipMoveLeft
	lda #%10000000	;Right?
	bit SWCHA 
	bne SkipMoveRight
        cpx #153
        bcs SkipMoveRight
        inx
SkipMoveRight
	stx XPos0
	rts
        
; Player 1 Movement
; ----------------
        
MoveJoystick1
; Move horizontally
        ldx XPos1
	lda #$04	;Left?
	bit SWCHA
	bne SkipMoveLeft1
        cpx #1
        bcc SkipMoveLeft1
        dex
SkipMoveLeft1
	lda #$08	;Right?
	bit SWCHA 
	bne SkipMoveRight1
        cpx #153
        bcs SkipMoveRight1
        inx
SkipMoveRight1
	stx XPos1
                
	rts

; Player 0 Button
; ---------------

FireButton0 subroutine
	bit INPT4	  ; read Joystick 1 button
        bmi .NoFireButton ; bit 7 set?
        lda MissileVel0   ; Check if missile is already fired. 
        ror ; Move value into carry to be checked easily
        bcs .NoFireButton ; Skip firing the missile (do not add on nto velocity)
        inc MissileVel0
.NoFireButton
	rts

; Player 1 Button
; ---------------

FireButton1 subroutine
	bit INPT5	  ; read Joystick 1 button
        bmi .NoFireButton ; bit 7 set?
        lda MissileVel1   ; Check if missile is already fired. 
        ror ; Move value into carry to be checked easily
        bcs .NoFireButton ; Skip firing the missile 
        inc MissileVel1
.NoFireButton
	rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 		Set Horizontal Position
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The X register contains the index of the desired object:
;  X=0: player 0
;  X=1: player 1
;  X=2: missile 0
;  X=3: missile 1
;  X=4: ball
SetHorizPos
	sta WSYNC	; start a new line
        bit 0		; waste 3 cycles
	sec		; set carry flag
DivideLoop
	sbc #15		; subtract 15
	bcs DivideLoop	; branch until negative
	eor #7		; calculate fine offset
	asl
	asl
	asl
	asl
	sta RESP0,x	; fix coarse position
	sta HMP0,x	; set fine offset
	rts		; return to caller
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 		      Miscellaneous 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        


; This will eventually be replaced by collisions increasing the score
JoystickButton subroutine
        bit INPT4
        bmi .SetNotPressed ; if the button is not pressed, set the pressed flag to 0
       	lda Pressed	   ; Otherwise, if it is already pressed, do not do anything 
        bne .skip           
        inc Pressed        ; Otherwise, set the flag nad add one to the score 
        
        ; Add one to the score
        clc
        sed
        lda Score0
        adc #1	
        sta Score0
        cld
        ; end add one to score
        
        jmp .skip
.SetNotPressed
	lda #0
        sta Pressed
.skip	
	rts
        
	org $FF00

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;			     BITMAPS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Scoreboard digits bitmap
; ------------------------

; Credit to 8BitWorkshop
; Bitmap pattern for digits
DigitsBitmap ;;{w:8,h:5,count:10,brev:1};;
        .byte $EE,$AA,$AA,$AA,$EE
        .byte $22,$22,$22,$22,$22
        .byte $EE,$22,$EE,$88,$EE
        .byte $EE,$22,$66,$22,$EE
        .byte $AA,$AA,$EE,$22,$22
        .byte $EE,$88,$EE,$22,$EE
        .byte $EE,$88,$EE,$AA,$EE
        .byte $EE,$22,$22,$22,$22
        .byte $EE,$AA,$EE,$AA,$EE
        .byte $EE,$AA,$EE,$22,$EE
;;end


;      Player 0 Bitmap
; ------------------------

;---Graphics Data from PlayerPal 2600---

Frame0
        .byte #0
        .byte #%01111110;$00
        .byte #%00111100;$00
        .byte #%00111100;$94
        .byte #%00111100;$94
        .byte #%00111100;$94
        .byte #%00111100;$94
        .byte #%00111100;$00
        .byte #%01111110;$94
        .byte #%01111110;$94
        .byte #%01111110;$94
        .byte #%01111110;$94
        .byte #%01111110;$94
        .byte #%00111100;$0E
        .byte #%00100100;$94
        .byte #%00100100;$94
        .byte #%00111100;$94
;---End Graphics Data---


;---Color Data from PlayerPal 2600---

ColourFrame0
        .byte #$0F; ; Colour of the missile
        .byte #$94;
        .byte #$94;
        .byte #$94;
        .byte #$94;
        .byte #$00;
        .byte #$94;
        .byte #$94;
        .byte #$94;
        .byte #$94;
        .byte #$94;
        .byte #$0E;
        .byte #$94;
        .byte #$94;
        .byte #$94;
        .byte #$94;
        .byte #$94;
        
;---End Color Data---


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue

	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector
