
	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

        seg.u Variables
	org $80

Temp		byte	; Temp variable, used for variety of purposees
DirtHeightCounter byte

; Scores 
Score0		byte	; Player 0 score
Score1		byte    ; Player 1 score

; Sprite Positions 
XPos0		byte	
XPos1		byte
ColP0   	byte	; Player0 colour on given scanline
ColP1		byte	; Player1 colour on given scanline

; Missile Positions
MissileY0	byte    
MissileY1	byte
MissileX0	byte
MissileX1	byte

Pressed 	byte



MissileHeight0  byte
MissileHeight1  byte
MissileVel0	byte
MissileVel1	byte

; Dirt 
Dirt		ds 36 	; 6x6 bytes (Dirt map)
; Sprite Pointers

ColourPtr0	word
ColourPtr1	word
SpritePtr	word

; Playfield Pointer

PFPtr		word

; Joystick Button 


; Score Font Buffer 2x5 array
FontBuf 	ds 10

; NUMBER OF BYTES OF RAM USED = 71

; Constants 
SpriteHeight 	equ #16
DefaultYPos	equ #0
Player0Colour   equ #$94
Player1Colour   equ #$42

DirtHeight	equ 8	; Height of each dirt spot in 2xScanlines
NumDirtRows	equ 6	; Number of dirt rows 
NDR		equ NumDirtRows
DirtYStart	equ 32 

; TODO use
BytesPerRow 	equ 6 	; Number of bytes (8 x 6 = 42 bits)
DirtPerRow 	equ 40 	; Number of Dirt spots per row 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment

	seg Code
        org $f000
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	              START
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Start
	CLEAN_START
        
        
        ; Temporary setup of dirt
        ldx #0
        lda #$ff
SetupDirt
        sta Dirt,x
        ;txa ; (un)comment for a 'random' looking pattern
        inx
        cpx #BytesPerRow*NumDirtRows
        bne SetupDirt
        		
        ; Setting Player Sprite Pointers 
        
        lda #<PlayerSprite
        sta SpritePtr
        lda #>PlayerSprite
        sta SpritePtr+1
        
        lda #<ColourFrame0
        sta ColourPtr0
        lda #>ColourFrame0
        sta ColourPtr0+1
          
        lda #<ColourFrame1
        sta ColourPtr1
        lda #>ColourFrame1
        sta ColourPtr1+1
        
        ; Intitial Scores and missile positions
        lda #0
        sta Score0
        sta Score1
        
        sta MissileHeight0
        sta MissileHeight1
        sta MissileY0
        sta MissileY1
        sta MissileVel0
        sta MissileVel1
        
        ; Initial Player and missile X positions
       	lda #40
        sta XPos0
        sta MissileX0
        lda #112
        sta XPos1
        sta MissileX1
        lda #1
        sta VDELP0	; Set delay for displaying P0 until GRP1 is set
         
        lda XPos0
        ldx #0
        jsr SetHorizPos
        
        lda XPos1
        ldx #1
        jsr SetHorizPos
        
        ldx #1
        sta WSYNC
        sta HMOVE

NextFrame
        lsr SWCHB	; test Game Reset switch
        bcc Start	; reset?
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	         VERTICAL SYNC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        
; 1 + 3 lines of VSYNC
	VERTICAL_SYNC
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	         VERTICAL BLANK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        
; 37 lines of underscan
	TIMER_SETUP 37 
      
       	; Setup the scores ready for display  
        lda Score0
        ldx #0
        jsr GetBCDBitmap
        lda Score1
        ldx #5
        jsr GetBCDBitmap
          
        ; Set the horizontal position of players
        lda XPos0
        ldx #0
        jsr SetHorizPos
        
        lda XPos1
        ldx #1
        jsr SetHorizPos
        
        ; Offset the missile0 to the center of sprite0
        lda XPos0
        clc
        adc #4
        ldx #2
        jsr SetHorizPos
        
        ; Offset the missile1 to the center of sprite1
        lda XPos1
        adc #4
        ldx #3
        jsr SetHorizPos
        
	; Setup background colour and scoremode ready for scoreboard
        lda #$00
        sta COLUBK
        lda #5
        sta CTRLPF	; Symmetry

        sta WSYNC
        sta HMOVE ; Apply horizontal offset 
       
        TIMER_WAIT
; 192 lines of frame
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	            DRAWING
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
	
        TIMER_SETUP 192 
        jsr DrawScoreboard
        
        ; Set Background to blue
        lda #$ba
        sta COLUBK
        
        ; DRAW PLAYER LOOP
        ; ----------------
        
        lda SpriteHeight
        sta Temp
DrawSpriteLoop
	ldy Temp
        
        lda (ColourPtr0),y	; Colour for both lines
        sta ColP0		; A -> ColP0
        lda (SpritePtr),y	; Bitmap for first line
        sta GRP0		; A -> [GRP0] (delayed due to VDELP0)
        
        lda (ColourPtr1),y
        tax
        lda (SpritePtr),y
        tay
        
        lda ColP0 
        sta WSYNC
        ; HBLANK
        sty GRP1	;GRP0 also updated due to VDELP0
        ; Store the player colours
        stx COLUP1
        sta COLUP0
        
        dec Temp
        
        lda Temp 
        sta WSYNC
        
        bne DrawSpriteLoop
        
        lda #0
        sta GRP0
        sta GRP1
        lda #$aF
        sta COLUP0
        sta COLUP1
        
        ; DRAW MISSILES LOOP (to be combined with playfield graphics loop)
        ; ------------------
                
        ; PLAYFIELD GRAPHICS LOOP
        ; ------------------
        
        lda #$54
        sta COLUPF
        
        ; Y contains the dirt row we are on.
        ; X contains the scanline we are on.
        
        ldy #$ff ; Start at -1 ; 
        ldx #$ff
DrawLoop
	iny 			; Go to next brick row
        
        lda #DirtHeight
        sta DirtHeightCounter
        cpy #NumDirtRows
        bcs DoneDirtDraw

.innerLoop
	
        ; Enable missiles
        ; -------------------
	
	inx			; increment scanline counter
        sta WSYNC
        
        lda #0			; Remove what was left in the Playfield registers
        sta PF0
        sta PF1                        
        sta PF2                  
        
        lda MissileVel0
        bmi .DisableMissile0
        stx Temp
        lda MissileY0
        cmp Temp		; If the scanline is more than the Missile Y, disable the missile
        lda #2
        bcs .EnableMissile0
.DisableMissile0
        lda #0
.EnableMissile0
        sta ENAM0		; Takes 14-16 machine cycles ; TODO Update
        
        lda MissileVel1
        bmi .DisableMissile1
        lda MissileY1	
        sec			; Set carry
        sbc Temp				
        lda #2		
        bcs .EnableMissile1
.DisableMissile1
        lda #0			
.EnableMissile1 	
	sta ENAM1		; Takes 14-16 machine cycles   
        			; At MAX this is 32 machine cycles ;TODO update
                                
        cpx #DirtYStart
        bmi .innerLoop
                           
        
        ; Next Scanline - draw playfield data
        ; -----------------------------------
        sta WSYNC
        
        ; HBLANK
        lda Dirt+NumDirtRows*0,y
        sta PF0
        lda Dirt+NumDirtRows*1,y
        sta PF1
        lda Dirt+NumDirtRows*2,y
        sta PF2			 ; 21 machine cycles - 1 off HBLANK
      	; END HBLANK
      	
        inx			 ; Increment scanline counter	
        
        nop			 ; timing - not counted towards total machine cycle use
        nop			 ; timing	
        nop			 ; timing	
        
        ; We have 8 machine cycles between these two (6 wasted machine cycles)
       
        lda Dirt+NumDirtRows*3,y
        sta PF0
        lda Dirt+NumDirtRows*4,y
        sta PF1
        lda Dirt+NumDirtRows*5,y
        sta PF2			 ; 21 machine cycles 
        			 ; TOTAL for PFx is 42 machine cycles. 76 - 42 machine cycles = 34	 
        
        dec DirtHeightCounter	
        
        bne .innerLoop
        beq DrawLoop		; Total 55 machine cycles used here, 21 machine cycles free 

DoneDirtDraw
	sta WSYNC
        
        ; Turn off missiles and playfield data
  	lda #0
        sta PF0
        sta PF1
        sta PF2
        sta ENAM0
        sta ENAM1
               
        TIMER_WAIT

; 29 lines of overscan

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	            OVERSCAN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	TIMER_SETUP 29
 
 	ldx #0
 	jsr MissileCollision
        ldx #1
        jsr MissileCollision
               
        sta CXCLR
        
        lda INPT4
	sta MissileVel0
        
        lda INPT5
	sta MissileVel1 
        
        jsr MoveJoystick0
        jsr MoveJoystick1
        
        TIMER_WAIT
; total = 262 lines, go to next frame
        jmp NextFrame

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 					Subroutines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; x - contains the player missile and player score to add to
MissileCollision subroutine
	lda CXM0FB,x
        sta Temp
	lda #%11000000
        bit Temp
        bne .collision
        beq .nocollision
.collision

	txa
        tay		; Move the player we are looking at into the Y register
        pha		; Save the contents of the X register
        
        lda MissileY0,y	; A contains missile Y coordinate  
        ldx XPos0,y	; X contains missile X coordinate
        
        jsr CleanDirt ; NOT WORKING CORRECTLY
        bmi .nocollision2
        
        
        pla
	tax		; Load the player we are looking at into the X register		

	; Add to the player score if there was a collision
	clc
        sed
        lda Score0,x
        adc #1	
        sta Score0,x
        cld
        jmp .nocollision
        
.nocollision2
	pla
        tax
.nocollision
	rts
        ; end add one to score
        

; Scoreboard Subroutines
; ----------------------
; Credit to 8Bitworkshop (Steven Hugg)

DrawScoreboard subroutine
	; Put playfield into score mode
        
        lda #%00010010
        sta CTRLPF
        lda #$98   ; Slightly lighter colour than player0 sprite
        sta COLUP0 ; left colour
        lda #$46   ; Slightly lighter colour than player1 sprite		
        sta COLUP1 ; right colour	
        ; Draw digits
        ldy #0
ScanLoop1a
        sta WSYNC ; 76
        tya
        lsr	   ; Divide Y by two for double-height lines 	
        tax	   ; A -> X
        lda FontBuf+0,x
        sta PF1		; set left score bitmap	
        SLEEP 28
        lda FontBuf+5,x
        sta PF1		; set right score bitmap
        iny
        cpy #10
        bcc ScanLoop1a
        
        ; Clear playfield
        lda #0
        sta WSYNC
        sta PF1
        ; Turn playfield reflection off (and turn score mode off)
        lda #%00010100
        sta CTRLPF
        rts

        
; GetBCDBitmap
; Fetches the bitmap data for two digits of a
; BCD-encoded number, storing it in addresses
; FontBuf+x to FontBuf+4+x
GetBCDBitmap subroutine 
	; Fetch the bytes for the 1st digit
        pha		; save original BCD number
        and #$0F	; mask out the least significant number
        sta Temp
        asl 
        asl
        adc Temp 	; multiply by 5
        tay		; A -> Y
        lda #5
        sta Temp	; count down from 5
.loop1
	lda DigitsBitmap,y
        and #$0F	; mask out left most digit
        sta FontBuf,x 
        iny
        inx
        dec Temp
        bne .loop1
        
        ; Second Digit 
        
	pla 		; restore original BCD number
        lsr
        lsr
        lsr
        lsr		;shift right by 4
        sta Temp
        asl 
        asl
        adc Temp	; multiply by 5
        tay 		; A -> Y
        dex
        dex
        dex
        dex
        dex
        lda #5
        sta Temp 	; count down from 5
.loop2
	lda DigitsBitmap,y
        and #$F0	; make out rightmost digit
        ora FontBuf,x	; combine left and right digts
        sta FontBuf,x	; store combined digits
        iny
        inx
        dec Temp
        bne .loop2
        rts
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; 			Clean Dirt
;	     Originally created by Steven Hugg
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        


; Subroutine to try to clear a bit of dirt at a given X-Y coordinate.
; X contains the X coordinate.
; A contains the Y coordinate.
; On return, A = -1 if no dirt was present,
; otherwise A = Y offset (0-brickheight-1) of dirt hit.
CleanDirt
        ldy #$ff
        sec
        sbc #DirtYStart	; subtract top Y of dirt field
; Divide by dirt height
DivideRowLoop
	iny
        sbc #DirtHeight*2
	bcs DivideRowLoop	; loop until < 0
        cpy #NumDirtRows
        bcs NoBrickFound
; Now that we have the line, get byte and bit offset for brick
	clc
        adc #DirtHeight*2
	pha	; save the remainder to return as result
	txa
        clc
        adc #3	; adjust because SetHorizPos is off by a few pixels
        lsr
        lsr	; divide X coordinate by 4
        tax	; transfer brick column to X
        tya	; load brick row # in A
        clc
        adc PFOfsTable,x	; add offset
        tay
        lda PFMaskTable,x
        eor #$ff
        and Dirt,y
        cmp Dirt,y		; was there a change?
        beq NoBrickFound2	; no, so return -1 as result
        sta Dirt,y
        pla		; return remainder as result
        rts
NoBrickFound2
	pla		; pull the remainder, but ignore it
NoBrickFound
	lda #$FF	; return -1 as result
        rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; 		Joystick Input Subroutines 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Player 0 Movement
; ----------------

; Read joystick movement and apply to object 0
MoveJoystick0 subroutine
; Move horizontally
        ldx XPos0
	lda #%01000000	;Left?
	bit SWCHA
	bne .SkipMoveLeft
        cpx #1
        bcc .SkipMoveLeft
        dex
.SkipMoveLeft
	lda #%10000000	;Right?
	bit SWCHA 
	bne .SkipMoveRight
        cpx #153
        bcs .SkipMoveRight
        inx
.SkipMoveRight
	stx XPos0
; Move Vertically
	ldy MissileY0
        lda #%00010000	;Up?
        bit SWCHA
        bne .SkipMoveUp
        cpy #1
        bcc .SkipMoveUp
        dey
        dey
.SkipMoveUp
        lda #%00100000	;down?
        bit SWCHA
        bne .SkipMoveDown
        cpy #DirtYStart+(DirtHeight*2*NumDirtRows)
        bcs .SkipMoveDown
        iny
        iny
.SkipMoveDown
        sty MissileY0  
        
	rts    
    
        
; Player 1 Movement
; ----------------
        
MoveJoystick1 subroutine 
; Move horizontally
        ldx XPos1
	lda #$04	;Left?
	bit SWCHA
	bne .SkipMoveLeft
        cpx #1		; Max Left
        bcc .SkipMoveLeft
        dex
.SkipMoveLeft
	lda #$08	;Right?
	bit SWCHA 
	bne .SkipMoveRight
        cpx #153	; Max Right
        bcs .SkipMoveRight
        inx
.SkipMoveRight
	stx XPos1
        
; Move Vertically
	ldy MissileY1
        lda #$01	;Up?
        bit SWCHA
        bne .SkipMoveUp
        cpy #1
        bcc .SkipMoveUp
        dey
        dey
.SkipMoveUp
        lda #$02	;down?
        bit SWCHA
        bne .SkipMoveDown
        cpy #DirtYStart+DirtHeight*2*NumDirtRows
        bcs .SkipMoveDown
        iny
        iny
.SkipMoveDown
        sty MissileY1   
        
	rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 		Set Horizontal Position
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The X register contains the index of the desired object:
;  X=0: player 0
;  X=1: player 1
;  X=2: missile 0
;  X=3: missile 1
;  X=4: ball
SetHorizPos
	sta WSYNC	; start a new line
        bit 0		; waste 3 cycles
	sec		; set carry flag
DivideLoop
	sbc #15		; subtract 15
	bcs DivideLoop	; branch until negative
	eor #7		; calculate fine offset
	asl
	asl
	asl
	asl
	sta RESP0,x	; fix coarse position
	sta HMP0,x	; set fine offset
	rts		; return to caller
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 		      Miscellaneous 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        

        
	org $FF00

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;			     BITMAPS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Scoreboard digits bitmap
; ------------------------

; Credit to 8BitWorkshop
; Bitmap pattern for digits
DigitsBitmap ;;{w:8,h:5,count:10,brev:1};;
        .byte $EE,$AA,$AA,$AA,$EE
        .byte $22,$22,$22,$22,$22
        .byte $EE,$22,$EE,$88,$EE
        .byte $EE,$22,$66,$22,$EE
        .byte $AA,$AA,$EE,$22,$22
        .byte $EE,$88,$EE,$22,$EE
        .byte $EE,$88,$EE,$AA,$EE
        .byte $EE,$22,$22,$22,$22
        .byte $EE,$AA,$EE,$AA,$EE
        .byte $EE,$AA,$EE,$22,$EE
;;end


;      Player 0 Bitmap
; ------------------------

;---Graphics Data from PlayerPal 2600---

PlayerSprite
        .byte #0
        .byte #%01111110;$00
        .byte #%00111100;$00
        .byte #%00111100;$94
        .byte #%00111100;$94
        .byte #%00111100;$94
        .byte #%00111100;$94
        .byte #%00111100;$00
        .byte #%01111110;$94
        .byte #%01111110;$94
        .byte #%01111110;$94
        .byte #%01111110;$94
        .byte #%01111110;$94
        .byte #%00111100;$0E
        .byte #%00100100;$94
        .byte #%00100100;$94
        .byte #%00111100;$94
;---End Graphics Data---


;---Color Data from PlayerPal 2600---

ColourFrame0
        .byte #$0; ; Colour of the missile
        .byte Player0Colour;
        .byte Player0Colour;
        .byte Player0Colour;
        .byte Player0Colour;
        .byte #$00;
        .byte Player0Colour;
        .byte Player0Colour;
        .byte Player0Colour;
        .byte Player0Colour;
        .byte Player0Colour;
        .byte #$0E;
        .byte Player0Colour;
        .byte Player0Colour;
        .byte Player0Colour;
        .byte Player0Colour;
        .byte Player0Colour;
        
ColourFrame1
        .byte #00 ; Colour of the missile
        .byte Player1Colour;
        .byte Player1Colour;
        .byte Player1Colour;
        .byte Player1Colour;
        .byte #$00;
        .byte Player1Colour;
        .byte Player1Colour;
        .byte Player1Colour;
        .byte Player1Colour;
        .byte Player1Colour;
        .byte #$0E;
        .byte Player1Colour;
        .byte Player1Colour;
        .byte Player1Colour;
        .byte Player1Colour;
        .byte Player1Colour;


; Playfield bitmasks for all 40 dirt columns
PFMaskTable
	REPEAT 2
	.byte #$10,#$20,#$40,#$80
	.byte #$80,#$40,#$20,#$10,#$08,#$04,#$02,#$01
	.byte #$01,#$02,#$04,#$08,#$10,#$20,#$40,#$80
        REPEND

; Dirt array byte offsets for all 40 dirt columns
PFOfsTable
	.byte NDR*0,NDR*0,NDR*0,NDR*0
	.byte NDR*1,NDR*1,NDR*1,NDR*1, NDR*1,NDR*1,NDR*1,NDR*1
	.byte NDR*2,NDR*2,NDR*2,NDR*2, NDR*2,NDR*2,NDR*2,NDR*2
	.byte NDR*3,NDR*3,NDR*3,NDR*3
	.byte NDR*4,NDR*4,NDR*4,NDR*4, NDR*4,NDR*4,NDR*4,NDR*4
	.byte NDR*5,NDR*5,NDR*5,NDR*5, NDR*5,NDR*5,NDR*5,NDR*5

;---End Color Data---


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue

	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector
